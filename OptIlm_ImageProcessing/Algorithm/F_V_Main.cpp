#include "InitialVariable.h"
#include "FunctionType.h"

#define DAY_OR_NIGHT_THRESHOLD				100
#define DAY_OR_NIGHT_FRAME_COUNTER_SIZE		30
#define IS_DAYTIME							1
#define IS_NIGHTTIME						0
#define DAY_OR_NIGHT_COUNTER_THRESHOLD		5

#define ADULT_DETECT_WIDTH                  15    //cm
#define ADULT_DETECT_HIGHT                  30    //cm
#define ADULT_SEARCH_Candidate_TH           0.7
#define ADULT_SEARCH_PREDICTED_TH           0.7
#define ADULT_DIRECTION_TH                  0.5


#define CHILD_DETECT_WIDTH                   8    //cm
#define CHILD_DETECT_HIGHT                  13    //cm
#define CHILD_SEARCH_Candidate_TH           0.85 //0.85
#define CHILD_SEARCH_PREDICTED_TH           0.8

enum HUMAN_DIRECTION {DIRECTION_FRONT, DIRECTION_BACK, DIRECTION_LEFT, DIRECTION_RIGHT};


//float adult_candidate_weights[37] =
////{-2.630719, -0.984454, -2.177647, 3.836297, 2.750774, 5.888888, 2.332798, 2.613475, 2.645556, -0.509180, -7.631802, -0.028616, 0.731409, 1.189724, 1.150788, 2.415384, 2.748026, 3.411175, 0.590963, -1.109900, -2.873962, -0.162189, 1.173735, 1.647267, 0.722720, 1.335425, 1.853479, 1.981286, -0.630383, 0.788209, 0.831961, 0.769763, 0.040861, 2.491718, 3.963158, 4.051147, -0.353641};
//{-11.817341, -4.246219, -1.073004, 7.792094, 8.931051, 15.782840, 4.107461, 3.805980, 1.778488, -5.174746, -11.544861, 0.622503, -0.998066, 3.080794, 3.185418, 7.291795, 6.299199, 6.847294, 3.315814, 0.483350, -1.544154, -0.601764, 2.184134, 3.069115, -0.031254, 1.152946, 3.843969, 4.724877, -2.338950, 1.375401, 1.656830, 0.699194, -3.175600, 4.220041, 8.257939, 10.787233, 1.539270};







//float adult_direction_weights[(ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT) + 1] =
//{0.201729, -0.359688, -0.370099, -0.469211, -0.910906, -0.925913, -0.615185, -0.918917, -0.568465, -0.664018, -1.151317, -0.057294, -0.235016, 0.128287, -0.525876, -0.449354, -0.188984, -0.473275, 0.051078, 0.463794, 0.754796, 0.228674, -1.445629, -1.428690, -0.927531, -0.845724, 1.267135, 0.522166, 1.299969, -0.712445, -1.384184, -0.483241, -0.545059, -0.576785, 0.346054, 1.056890, 1.428681, -0.779957, -1.789695, -1.420389, 0.368755, 1.471852, 1.295055, 1.855396, -0.742940, -1.480373, -0.104452, -0.287974, -0.215807, 0.405590, 0.833212, 0.952625, -0.415584, -1.884028, -1.275479, 0.266034, 1.224660, 0.837750, 1.046594, -0.346941, -0.163971, -0.062406, -0.177798, -0.355515, -0.085882, 0.439646, -0.107405, 0.380901, -1.260646, -1.224864, 0.572415, 1.426854, 1.070985, 0.979008, -0.427700, -0.059050, -0.001196, -0.075297, -0.316289, -0.262273, 0.235006, 0.148847, 1.030911, -0.481427, -1.302903, 1.525463, 2.030050, 1.688237, 1.356310, -0.431214, -0.035602, -0.052486, -0.050541, -0.208097, -0.372042, 0.216760, 1.104873, 1.290692, 0.782600, -0.523728, 2.391209, 1.629844, 2.422186, 0.843834, -0.456275, -0.041120, -0.020092, -0.068702, -0.170153, -0.464304, 0.129099, 0.979795, 0.493566, 0.716983, 0.395909, 2.053491, 1.629744, 1.230148, -0.510684, -0.479555, -0.019041, -0.021145, -0.002459, -0.029243, -0.210252, -0.232746, 0.472832, 0.311019, 1.248382, 0.801217, 1.597954, 1.331020, 0.862946, -0.612107, -0.620353, -0.227843, -0.119481, -0.084789, -0.140899, -0.186110, -0.264612, 0.038065, -0.110237, 0.861894, 1.080202, 0.542811, 0.421531, -0.214259, -0.818373, -0.438927, -0.000254, -0.061978, -0.066161, -0.197276, -0.373758, -0.117003, 0.643992, 0.467904, 0.343462, 1.530926, 1.184084, -0.151451, -0.728997, -1.554124, -0.788906, -0.330165, -0.018790, -0.024506, -0.032201, -0.273673, -0.175729, 0.409977, 0.339738, 0.138023, 1.077711, 0.146572, -1.254004, -0.942026, -1.861612, -1.008880, -0.381787, -0.019788, 0.411859, 0.429522, -0.094128, 0.404736, -0.074916, -0.039387, 1.404768, 0.806075, -0.618665, -0.524814, -1.687255, -1.510430, -1.072294, -0.246813, -0.073978, 0.787083, 1.811741, 0.813399, 0.725950, 0.512732, -0.238496, 1.858489, 0.408433, -0.034156, -0.331392, -2.818352, -2.478919, -1.911989, -0.978855, -0.082908, 0.136750, 1.760895, 1.271401, 0.765704, 0.646747, -0.227449, 1.083950, -0.378959, -1.028250, -1.271867, -3.429653, -3.367459, -2.418019, -1.765727, -0.048931, -0.207872, 0.318775, 1.042545, 0.925654, 0.137993, -0.360010, -0.049747, 0.307798, -1.612398, -1.734037, -1.511951, -2.462113, -2.401482, -1.917172, 0.001560, -0.110547, -0.064077, 0.102384, 0.383601, 0.038955, -0.626877, -0.546325, -1.273145, -1.591001, -3.276381, -1.707828, -1.369150, -2.344973, -0.979318, 0.025571, -0.068086, -0.110815, -0.275657, -0.633743, -0.176045, -1.059053, -1.292179, -2.138340, -1.398783, -0.579958, -1.274659, 0.251483, 0.129816, -0.017892, -0.013944, -0.055661, -0.148589, -0.228916, -0.495239, -0.055228, -0.281131, -0.956149, -1.516872, -0.425082, 0.417799, -0.176763, 0.393657, 1.677535, -0.011750, -0.003095, 0.017573, -0.052273, -0.174919, -0.147411, -0.200392, -0.185715, -1.245828, -2.415545, -2.435377, -2.191895, -0.708249, -0.444342, 1.246045, 0.001669, 0.017330, -0.084566, -0.090203, -0.123243, -0.507070, -0.668548, -0.247910, -0.331670, -1.904029, -2.914813, -2.425534, 0.080178, 0.358506, 0.583318, -0.011229, 0.029371, -0.046960, -0.073925, -0.048650, -0.367188, -0.932504, -1.412060, -1.804139, -2.872730, -0.624699, -1.205847, 0.448142, 1.139165, 0.182123, -0.010781, 0.037707, -0.033327, -0.054006, -0.073760, -0.090311, -0.091450, -0.348807, -1.036500, -1.162360, 0.164093, -0.118403, -0.054556, 0.719941, 0.191468, -0.018306, -0.003601, -0.001027, -0.060051, 0.008672, -0.039604, -0.211722, -0.706412, -1.133769, 0.003691, 0.341601, 0.074682, -0.217264, 0.956250, -0.015056, -0.010774, -0.021539, -0.000992, -0.046828, -0.105236, -0.069223, -0.092283, -0.640155, -0.261814, 1.206264, 0.931755, 0.885600, 1.327787, 1.612729, -0.190890, -0.008274, -0.020355, -0.037037, -0.047850, -0.107079, -0.082944, -0.571642, -0.759736, -0.268327, 1.366006, 1.504999, 2.423352, 3.055692, 0.933010, -0.145648, 0.008046, -0.040349, -0.010758, -0.000754, -0.049316, -0.256091, -0.399648, 0.758664, 2.422193, 2.686339, 3.334860, 1.415180, 0.200351, -0.039762, -0.095791, -0.002586, -0.011867, -0.000871, -0.000565, -0.000891, 0.005375, -0.007311, -0.073475, -0.007792, -0.004774, -0.008627, -0.013238, -0.022900, -0.041760, -0.024964, -0.000495, -0.006615, -0.002792, -0.000378, -0.007787, -0.010185, 0.121740, -0.053601, -0.007677, -0.007010, -0.006062, -0.020857, -0.021306, -0.007363, 0.000612, 0.000028, 0.007030, -0.003897, -0.001694, -0.021140, -0.011261, -0.006511, -0.029172, -0.006649, -0.008782, -0.015368, -0.005023, 0.051567, 0.000028, 0.000738, 0.000000};


//float adult_weights[(ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT) + 1] =
////{-3.265594, -0.430844, -0.717710, -0.896156, -0.658513, -0.559208, -0.350668, -0.117357, -1.243414, -0.757566, -0.411743, -0.212033, -0.870858, -0.453170, 0.742589, 2.263852, 1.839834, 1.555978, 1.473942, 1.024452, 0.807335, 0.558465, 0.209828, 0.018484, -0.003893, 1.314594, 1.018005, 1.665532, 3.286150, 3.785002, 4.491933, 5.612357, 3.824594, 2.449087, 1.525652, 0.912039, 0.243650, 0.357340, 0.184585, 0.124314, 0.998164, 0.204343, 0.722394, 0.752752, 1.391942, 2.236456, -0.830318, -0.698188, -0.018413, -0.862049, -0.741793, -0.691929, -0.855908, -0.243530, -0.756373, -0.247284, -1.017125, -0.618397, -0.639072, -0.574544, -0.472652, -0.514506, -0.397054, -0.182930, -0.186941, -0.469240, -0.293686, -0.456168, 0.223971, -0.116395, 0.198481, -0.532476, -0.198401, -0.201876, -0.220371, -0.068350, -0.688436, -0.278092, -0.276134, -0.069793, -0.339688, -0.557977, -0.551317, 0.657693, -0.454165, 0.089850, -0.614573, -0.896176, -0.533196, -0.557121, -0.382444, 0.103264, -0.114877, -0.147897, -0.199980, -0.109554, -0.563231, -0.480691, 0.456616, -0.389936, -0.186795, -0.393763, -0.604631, -0.503348, -0.592132, -0.226609, 0.079957, 0.240437, 0.581848, 0.354573, 0.452593, 0.028180, 0.117612, 0.199611, -0.354688, -0.466944, -0.398202, -0.248629, 0.339816, -0.022426, -0.617622, -0.119730, -0.565152, -0.419751, -0.095240, 0.918274, 0.218659, -0.139567, -0.242320, -0.493782, -0.208200, 0.814606, -0.349409, 0.356784, 0.931150, 1.122111, 1.193713, 0.927492, 1.034929, 0.421903, 0.253443, 0.223407, 0.033319, -0.250397, 0.561796, -0.037999, -0.055216, 0.515640, 0.658522, 0.536616, -0.534281, -0.042413, -0.099949, -0.436816, -0.586824, -0.240590, -0.227657, 0.070791, 0.452576, 0.796884, 1.999830, 0.417303, 1.120605, 1.171486, 0.779106, -0.456753, -0.548985, -0.637358, -0.870028, -0.764627, -0.290220, 0.258816, 1.187137, 2.195950, 1.377536, 2.098046, 0.179262, 1.093252, 0.409152, 1.245365, -0.607239, -0.777497, -0.787465, -1.268521, -1.354344, 0.069902, 0.729885, 0.928415, 0.887472, 0.382325, 0.594495, -0.429897, 0.892156, 0.284757, 1.532653, -0.557396, -0.860489, -0.931289, -1.061067, -0.982274, -0.925265, -0.289025, 0.413722, 0.143555, 1.043954, -0.797077, 0.230904, 1.326969, 1.495481, 2.456306, -0.339701, -0.791899, -0.786732, -0.302882, 0.065101, -0.608166, 0.335491, 0.041720, -0.048888, 1.333673, 0.166007, 0.504059, 1.119984, 1.513837, 2.278356, 0.027025, -0.800848, -0.699428, -0.635285, -0.169030, -0.520872, -0.552060, -0.506593, -0.690224, 0.872636, 1.329964, 0.420289, 1.940619, 1.700129, 2.014569, -0.069389, -0.473786, -0.903431, -0.895943, -0.234741, -0.403265, -0.857102, -0.228942, -0.003523, 1.412163, 0.672384, 0.936789, 2.045572, 1.146349, 1.897806, 0.047054, -0.441458, -0.909807, -0.975864, -0.548420, -0.032136, 0.282662, 1.030997, 0.636681, 0.596753, -0.897007, 0.027807, 0.318776, 0.343058, 1.597327, 0.342642, -0.451186, -0.791217, -0.711435, -0.633803, 0.081798, 0.697299, 0.734632, -0.638951, -0.777263, -1.185054, 0.008696, -0.163929, 0.468595, 1.696041, -0.186912, -0.664923, -0.588911, -0.745572, -0.711196, -0.649798, 0.764110, 1.000405, -0.033423, 1.934924, 1.656934, 1.592363, 0.702569, 0.405546, 1.498664, -0.293384, -0.570051, -0.404199, -0.525971, -0.565838, -0.595840, 0.660991, 0.195334, 1.714752, 0.386222, 0.883229, 0.914149, 0.465003, -0.316270, 1.420656, -0.388258, -0.508149, -0.538746, -0.608623, -0.868401, -0.448630, 0.413143, 0.815386, 1.895990, -0.074992, -0.952812, -0.576774, -1.389414, -0.605110, 1.359090, -0.551421, -0.465257, -0.556020, -0.874455, -0.762905, -0.496263, 0.394307, -0.249437, 0.748168, -0.284663, -0.583728, -0.526375, -1.190380, -0.003951, 1.284831, -0.662087, -0.620332, -0.733920, -0.612966, -0.634924, -0.432354, 0.171906, -0.236586, 0.571425, 0.768687, 0.465102, -0.019607, -0.523269, 0.398626, 1.013636, -0.629656, -0.477629, -0.795466, -0.658820, -0.500217, -0.064383, -0.168470, 0.404761, 2.516735, 0.782910, 0.796316, 0.709364, 0.416625, 0.544177, 0.971460, -0.573472, -0.483294, -0.259271, 0.013393, -0.341221, 0.599878, 1.953348, 2.600861, 3.353471, 2.170324, 2.496132, 1.262117, 2.005809, 0.966800, 1.220711, -0.118749, -0.220437, -0.294186, 0.003246, 0.099139, 0.364636, -0.084551, 0.400219, 0.411693, 0.467075, 0.447767, 1.167907, 0.751806, -0.195655, 0.535028, -0.868593, -0.419945, -0.483661, -0.400436, -0.426888, -0.428455, -0.565987, -0.271022, -0.819305, -1.184475, -1.222693, -0.909211, -1.120087, -1.083301, 0.084613, -1.055727, -0.520872, -0.450193, -0.420499, -0.477602, -0.484702, -0.397058, -0.279848, -0.726816, -1.109658, -1.070709, -0.939025, -0.998046, -1.037870, 0.092666, -1.239824, -0.573156, -0.443877, -0.492533, -0.478718, -0.490457, -0.559602, -0.177752, -0.532088, -0.767008, -1.128890, -0.713416, -0.640088, -0.882997, -0.108082, -1.234641};
//{-1.203768, -0.221084, -0.265705, -0.310677, -0.288682, -0.199489, -0.065266, -0.162320, -0.550889, -0.251863, 0.154790, 0.119811, -0.182671, -0.059630, 0.370035, 0.948770, 0.976598, 0.922593, 0.818677, 0.596665, 0.491212, 0.289885, -0.040096, -0.033785, 0.119548, 1.068540, 0.767295, 1.046392, 1.550828, 1.950520, 2.262869, 2.687480, 2.196747, 1.511412, 0.964990, 0.582628, 0.075931, 0.042621, 0.085799, 0.225413, 0.931166, 0.453570, 0.570324, 0.575185, 1.029131, 1.330769, -0.358854, -0.283600, 0.110725, -0.292491, -0.296356, -0.328253, -0.490708, -0.138456, -0.229086, 0.247543, -0.255718, -0.141032, -0.130023, -0.078071, -0.083539, -0.161165, -0.103975, 0.047289, 0.091935, -0.214972, -0.217788, -0.302081, 0.025599, -0.026801, 0.395482, -0.129882, 0.016613, 0.037313, 0.020742, 0.012230, -0.270509, -0.117016, -0.075404, 0.105864, -0.135838, -0.307252, -0.306705, 0.182349, -0.097166, 0.338002, -0.200036, -0.202042, -0.043861, -0.118298, -0.092333, 0.069640, -0.009472, -0.028739, 0.017167, 0.016745, -0.268285, -0.240396, 0.116585, 0.074884, 0.174595, -0.147040, -0.072381, 0.001382, -0.130802, 0.016387, 0.092699, 0.191334, 0.303882, 0.262606, 0.357353, 0.013996, 0.081581, 0.029622, 0.092600, 0.051173, -0.048770, 0.118018, 0.359950, 0.194600, -0.117385, -0.052252, -0.181105, -0.150316, 0.003519, 0.525894, 0.157999, 0.019991, -0.143675, 0.058681, 0.192065, 0.513001, 0.111797, 0.365392, 0.636598, 0.667130, 0.489641, 0.371651, 0.432312, 0.196652, 0.118982, 0.144200, 0.112701, -0.152247, 0.457224, 0.318043, 0.079528, 0.394645, 0.472596, 0.441441, -0.095533, -0.032004, -0.103071, -0.234904, -0.224812, -0.044159, -0.065624, 0.134157, 0.153858, 0.347792, 1.401629, 0.288945, 0.508501, 0.640729, 0.498019, -0.123418, -0.268517, -0.341920, -0.447672, -0.359105, -0.124434, 0.167357, 0.694336, 1.043567, 0.741832, 1.589573, 0.214716, 0.488855, 0.300023, 0.716698, -0.156762, -0.372528, -0.398698, -0.686088, -0.659573, 0.038228, 0.417341, 0.574864, 0.459172, 0.491077, 0.797475, -0.045548, 0.512488, 0.248543, 0.845213, -0.151898, -0.422939, -0.454729, -0.567704, -0.497626, -0.529828, -0.139140, 0.264012, 0.218611, 0.996101, -0.018708, 0.319710, 0.831819, 0.909897, 1.294751, -0.047960, -0.389608, -0.399505, -0.130087, 0.057588, -0.321499, 0.088129, 0.025913, 0.166625, 1.132955, 0.431834, 0.410929, 0.888851, 0.874743, 1.185054, 0.089117, -0.398209, -0.351880, -0.277398, -0.047328, -0.243128, -0.221667, -0.266676, -0.155701, 0.874946, 1.101795, 0.372763, 1.152882, 0.848754, 1.118283, -0.044684, -0.254499, -0.445632, -0.420321, -0.024606, -0.153919, -0.384677, -0.150049, 0.160820, 1.180195, 0.727041, 0.622093, 1.147777, 0.518762, 1.077881, -0.038596, -0.239271, -0.457999, -0.510096, -0.235954, -0.028982, 0.076047, 0.593702, 0.545588, 0.751247, -0.030759, 0.145533, 0.278809, 0.173440, 0.957457, 0.061596, -0.246815, -0.434456, -0.410036, -0.311181, 0.046367, 0.343550, 0.515021, -0.053179, 0.038779, -0.218808, 0.199723, -0.043322, 0.228095, 1.026768, -0.056341, -0.363293, -0.340503, -0.394753, -0.339807, -0.283253, 0.437225, 0.557720, 0.265178, 1.549164, 1.026754, 0.936345, 0.151181, 0.199812, 0.942867, -0.051543, -0.328999, -0.248672, -0.281815, -0.249771, -0.247084, 0.304312, 0.253784, 1.380706, 0.741920, 0.666430, 0.507127, 0.067443, -0.095904, 0.865663, -0.099796, -0.287391, -0.312084, -0.305587, -0.387437, -0.224757, 0.232100, 0.668650, 1.465527, 0.245212, -0.218772, -0.195081, -0.554432, -0.269176, 0.830376, -0.151771, -0.243892, -0.299768, -0.439108, -0.347744, -0.223303, 0.271381, 0.118781, 0.744320, 0.200099, 0.054767, -0.116328, -0.425326, 0.007845, 0.778705, -0.178524, -0.292237, -0.351712, -0.302628, -0.249456, -0.187193, 0.236319, 0.155706, 0.634810, 0.726284, 0.582479, 0.154226, -0.130600, 0.222551, 0.700642, -0.164803, -0.221211, -0.363830, -0.283649, -0.159439, 0.028860, 0.057137, 0.522399, 1.694631, 0.663407, 0.636724, 0.394405, 0.188624, 0.334175, 0.693858, -0.171639, -0.221637, -0.155767, -0.034147, -0.122447, 0.192638, 1.066319, 1.700986, 2.067010, 1.287166, 1.429227, 0.494613, 0.728523, 0.569097, 0.687570, -0.048233, -0.092949, -0.147212, -0.072610, -0.033890, 0.023569, -0.050739, 0.316192, 0.363634, 0.363651, 0.182992, 0.423642, 0.309029, -0.030928, 0.487938, -0.261174, -0.198829, -0.209889, -0.146738, -0.165562, -0.148730, -0.185910, 0.021419, -0.205469, -0.319893, -0.385965, -0.348342, -0.387918, -0.310486, 0.374173, -0.332322, -0.206207, -0.210088, -0.164681, -0.182703, -0.183087, -0.105169, 0.005308, -0.199610, -0.340872, -0.405699, -0.350182, -0.365992, -0.293995, 0.343619, -0.387651, -0.231144, -0.196011, -0.175335, -0.165242, -0.174265, -0.175227, 0.026155, -0.175107, -0.293330, -0.436530, -0.323608, -0.260217, -0.260268, 0.265616, -0.389364};





float child_candidate_weights[37] =
{-2.630719, -0.984454, -2.177647, 3.836297, 2.750774, 5.888888, 2.332798, 2.613475, 2.645556, -0.509180, -7.631802, -0.028616, 0.731409, 1.189724, 1.150788, 2.415384, 2.748026, 3.411175, 0.590963, -1.109900, -2.873962, -0.162189, 1.173735, 1.647267, 0.722720, 1.335425, 1.853479, 1.981286, -0.630383, 0.788209, 0.831961, 0.769763, 0.040861, 2.491718, 3.963158, 4.051147, -0.353641};

float child_weights[(CHILD_DETECT_WIDTH * ADULT_DETECT_HIGHT)+1] = {0.083283, 1.341998, -0.966063, -0.346477, 0.521917, -0.176631, -0.574991, -0.749758, -0.726817, -0.406294, -0.870956, 0.056591, 0.652117, 1.213785, 0.332521, 0.460299, -0.478211, -1.396025, -0.983457, -0.265270, -0.227555, 0.894959, 1.827694, 0.606209, -0.688298, -0.549505, -0.111055, -0.758642, -1.039164, -0.410945, 1.592163, 1.334745, 0.199380, 1.363056, 0.495517, 0.213363, 0.867151, -0.727980, 1.473254, 0.760986, 0.244339, 0.600543, 0.720922, 0.311579, 1.774515, 0.568738, 1.760040, 1.503004, 0.563412, -0.392053, -0.167586, -0.001188, -0.226743, 0.000102, 0.511440, 0.825891, 2.760179, 0.791843, -0.032032, 0.718363, -0.631417, -0.695825, 0.583513, 1.479708, -0.722254, -1.688249, -1.726462, -2.592436, -2.326404, -1.220868, 0.558788, -0.172907, -0.168220, -2.073463, -2.092570, -2.235879, -0.160868, 2.794446, 5.096665, 3.090056, 1.264145, -2.304781, -1.548869, -1.095337, 1.506345, 4.167614, 3.598728, 0.712718, -1.868674, -1.412510, -1.478460, -1.436254, -2.008998, -2.251161, -1.822526, -2.130948, -2.606735, -1.430711, -1.798146, -1.512530, -1.294723, -2.156756, -1.930917, -2.069287, -2.357838};





//int adult_candidate_data[36] = {25,64,44,99,53,46,36,33,46,25,20,18,16,14,13,15,20,59,20,13,11,11,10,9,12,10,11,3,2,3,4,5,7,11,15,33};

int child_candidate_data[36] = {36,59,44,62,64,65,61,73,95,91,56,45,41,39,54,47,58,85,54,52,44,35,30,23,29,20,17,12,5,6,9,12,17,15,15,13};
//{39,89,69,98,78,77,71,73,72,56,42,39,29,28,27,27,30,50,38,35,32,28,27,25,16,16,13,13,7,7,12,13,16,19,14,12};





float adult_candidate_weights[37] =
//{-15.087936, -5.760173, -3.624172, 9.676656, 4.232430, 11.994973, 5.226532, 1.490404, -2.823863, -4.224174, -0.626989, 0.815775, -6.756422, 3.649139, 3.179631, 5.968294, 12.671117, 12.023729, 1.615864, 2.621217, 7.504842, 6.895583, 10.007232, 7.681609, 0.119203, -1.188213, 5.638276, 7.475303, 0.910556, 3.959450, 6.849162, 2.309555, -0.854353, 3.377143, 1.262503, 8.377258, -1.403285};
{-2.630719, -0.984454, -2.177647, 3.836297, 2.750774, 5.888888, 2.332798, 2.613475, 2.645556, -0.509180, -7.631802, -0.028616, 0.731409, 1.189724, 1.150788, 2.415384, 2.748026, 3.411175, 0.590963, -1.109900, -2.873962, -0.162189, 1.173735, 1.647267, 0.722720, 1.335425, 1.853479, 1.981286, -0.630383, 0.788209, 0.831961, 0.769763, 0.040861, 2.491718, 3.963158, 4.051147, -0.353641};
//{-11.817341, -4.246219, -1.073004, 7.792094, 8.931051, 15.782840, 4.107461, 3.805980, 1.778488, -5.174746, -11.544861, 0.622503, -0.998066, 3.080794, 3.185418, 7.291795, 6.299199, 6.847294, 3.315814, 0.483350, -1.544154, -0.601764, 2.184134, 3.069115, -0.031254, 1.152946, 3.843969, 4.724877, -2.338950, 1.375401, 1.656830, 0.699194, -3.175600, 4.220041, 8.257939, 10.787233, 1.539270};




float adult_direction_weights[(ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT) + 1] =
{0.802847, 0.343705, 0.459067, 0.512107, 0.579620, 0.272078, 0.402301, 0.552303, -0.026902, -1.051775, -1.901582, -2.262278, -1.148408, -0.756204, -0.428949, -0.307523, 0.479128, 1.722417, 2.638525, 1.535352, 0.902534, 2.774606, 0.765451, -0.662915, -2.282450, -2.793840, -1.832762, -0.881139, -0.920100, -0.599702, -0.184440, 1.921102, 2.048204, 0.822519, 1.420340, 1.191461, 1.683219, -0.782392, -0.771516, -0.333531, -2.505021, -1.823113, 1.102931, 0.335251, -0.854113, -0.025186, 2.021297, 1.477277, 0.711798, 1.016884, -0.017967, -0.705686, -1.308010, -1.511441, -0.450163, -0.332555, 0.476167, 0.906718, 0.082923, -0.471116, 0.000000, 2.340074, 1.567399, 0.732173, 0.282748, 0.556777, -1.584479, -0.721084, -1.250388, -1.026104, -0.762045, 0.235881, 0.924975, 0.050036, -0.293834, 0.000000, 1.195961, 0.697747, 0.555711, 0.319483, 0.535912, -0.971094, -0.624618, -0.232591, -0.614105, -1.497625, -0.190322, 0.530982, -0.234797, -0.539797, -0.425556, 0.581447, 0.637841, 0.480619, -0.354843, 0.482236, -0.920593, -1.011477, 0.039969, 0.070984, -1.403789, 0.712543, 1.562285, -0.132526, -0.201216, -0.551453, 0.494780, 0.497407, 0.276285, -0.382558, -0.960928, -1.198781, -1.793313, 0.182627, 0.962511, -0.441700, 1.110813, 1.229614, -0.414107, -0.659575, -0.512384, 0.172314, 0.015052, -0.058981, -0.230835, -1.262826, -0.987885, -2.112934, -0.142120, 0.524185, 0.097424, 0.399807, 0.027940, -0.452509, -0.889531, -0.346109, -0.062999, -0.075542, -0.132542, -0.147583, -0.289851, -0.066668, -0.633649, 0.443326, 0.038446, 0.200804, 0.019822, -0.247095, -0.206693, -0.445475, -0.646186, -0.065999, -0.226079, -0.011098, 0.013332, 0.560472, -0.129843, -0.852490, 0.438386, 0.294727, -0.205134, -0.300859, -0.562432, -0.390986, -0.443634, -0.404818, -0.154690, 0.002225, -0.015266, 0.078012, 0.305101, -1.001834, -0.742920, -1.124697, -0.550081, -0.208828, -0.302736, 0.007965, -0.263870, -0.650231, -0.111916, -0.001780, -0.023837, -0.333725, -0.444434, -0.738905, -0.145148, -0.250963, -1.165780, -0.630165, 1.008762, -1.632952, 0.831325, -0.197743, -0.878702, -0.051440, -0.099698, -0.151069, -0.922109, -1.309768, -1.568052, -0.891310, -0.009995, -0.200926, -1.890354, 0.759782, 0.209312, 1.370699, 0.306929, 0.421649, 0.000997, -0.024742, 0.223698, -0.154262, -0.096624, -0.866029, 1.100482, 1.463372, 1.327459, 1.786640, 1.046886, -0.020565, 1.232288, 0.041756, -0.258768, -0.122463, -0.013635, 0.436011, 2.212871, 1.015580, 3.401921, 2.038958, 1.362353, 0.774773, -0.563725, -1.332967, -2.180531, -1.258704, -1.149136, -1.423261, -0.343120, -0.032725, -0.067011, 1.611300, 1.729728, 0.503577, 0.711861, 0.903458, -0.830301, -0.464920, -2.396910, -1.881263, -0.691197, 0.020405, -1.066108, -0.645243, 0.154367, -0.294078, 0.039110, 0.170748, 2.168140, -1.204501, -0.228026, -0.577881, -3.127963, -1.727360, 0.044616, 0.103221, 0.245974, -0.740730, -0.276669, 0.514775, -0.509091, -0.382955, -0.030596, 0.661250, -0.762213, -0.196383, -1.111634, -1.398561, -0.804315, 1.119745, 0.896804, -0.083672, -0.360996, -0.011044, 0.334442, -0.189684, 0.164721, 0.785755, 0.336845, -0.905289, 1.811099, 1.671372, 1.766653, 1.148039, 1.152694, 1.033471, -0.089420, -0.319680, 0.000000, -0.068468, -1.404831, -0.962621, 0.600964, 0.226416, 0.937990, 1.424833, 2.236638, 2.911382, 2.625640, 2.064057, 0.949763, 0.059746, -0.000946, 0.000000, -0.433682, 0.619456, -0.295311, 0.787329, -1.576378, -1.372186, -0.270640, 1.823197, 2.024042, 1.675336, 1.829350, 0.368679, -0.209028, 0.057380, 0.000000, 0.635141, 0.557462, -0.518149, 1.538364, -1.730814, -0.924059, -1.770490, -1.192629, -2.163711, -0.810890, 0.304721, -0.037705, -1.266357, 0.045407, 0.000000, -1.234280, 0.587095, -0.022452, 0.031426, -0.440363, 0.677324, -0.771659, -1.109532, -0.256218, 0.205973, 0.431866, 0.018124, -0.485214, 0.654638, 0.927823, -1.484564, 1.073875, -0.625252, -0.516449, 0.295265, 3.449859, 1.554385, 0.868452, 1.345685, -0.118386, 0.262654, 0.313564, 0.752267, 1.457503, 1.241155, -1.079817, 0.613366, -0.181215, -0.185259, -1.273539, -1.810799, -0.706372, -1.899830, 1.046522, 0.967778, 1.410097, 0.619484, 1.137177, 1.171981, 1.518207, -0.430994, 0.319956, 0.011359, -0.759505, 0.774268, 0.520615, -0.523441, -0.457983, 1.793963, 0.765868, 0.674286, 0.259859, 0.595673, 0.246737, 1.097421, -0.598353, 0.412973, -0.106596, -0.442837, -0.231660, 0.758299, -0.121433, -0.897299, 0.365326, -0.973190, -1.329348, -0.177581, 0.132018, 0.346837, 0.249689, -0.375802, -0.437680, 0.323477, -0.541866, -1.190338, -0.272158, 0.863612, -0.701801, -1.764021, -0.431464, -1.255282, 0.463507, -0.208152, 0.414912, 0.205659, -1.085813, -0.706266, 0.373175, -0.710492, -0.974002, -0.683273, -1.286937, -0.248437, 0.395980, -0.438053, -1.436046, -0.994087, 0.173338, 0.142717, 0.052925};
//{0.201729, -0.359688, -0.370099, -0.469211, -0.910906, -0.925913, -0.615185, -0.918917, -0.568465, -0.664018, -1.151317, -0.057294, -0.235016, 0.128287, -0.525876, -0.449354, -0.188984, -0.473275, 0.051078, 0.463794, 0.754796, 0.228674, -1.445629, -1.428690, -0.927531, -0.845724, 1.267135, 0.522166, 1.299969, -0.712445, -1.384184, -0.483241, -0.545059, -0.576785, 0.346054, 1.056890, 1.428681, -0.779957, -1.789695, -1.420389, 0.368755, 1.471852, 1.295055, 1.855396, -0.742940, -1.480373, -0.104452, -0.287974, -0.215807, 0.405590, 0.833212, 0.952625, -0.415584, -1.884028, -1.275479, 0.266034, 1.224660, 0.837750, 1.046594, -0.346941, -0.163971, -0.062406, -0.177798, -0.355515, -0.085882, 0.439646, -0.107405, 0.380901, -1.260646, -1.224864, 0.572415, 1.426854, 1.070985, 0.979008, -0.427700, -0.059050, -0.001196, -0.075297, -0.316289, -0.262273, 0.235006, 0.148847, 1.030911, -0.481427, -1.302903, 1.525463, 2.030050, 1.688237, 1.356310, -0.431214, -0.035602, -0.052486, -0.050541, -0.208097, -0.372042, 0.216760, 1.104873, 1.290692, 0.782600, -0.523728, 2.391209, 1.629844, 2.422186, 0.843834, -0.456275, -0.041120, -0.020092, -0.068702, -0.170153, -0.464304, 0.129099, 0.979795, 0.493566, 0.716983, 0.395909, 2.053491, 1.629744, 1.230148, -0.510684, -0.479555, -0.019041, -0.021145, -0.002459, -0.029243, -0.210252, -0.232746, 0.472832, 0.311019, 1.248382, 0.801217, 1.597954, 1.331020, 0.862946, -0.612107, -0.620353, -0.227843, -0.119481, -0.084789, -0.140899, -0.186110, -0.264612, 0.038065, -0.110237, 0.861894, 1.080202, 0.542811, 0.421531, -0.214259, -0.818373, -0.438927, -0.000254, -0.061978, -0.066161, -0.197276, -0.373758, -0.117003, 0.643992, 0.467904, 0.343462, 1.530926, 1.184084, -0.151451, -0.728997, -1.554124, -0.788906, -0.330165, -0.018790, -0.024506, -0.032201, -0.273673, -0.175729, 0.409977, 0.339738, 0.138023, 1.077711, 0.146572, -1.254004, -0.942026, -1.861612, -1.008880, -0.381787, -0.019788, 0.411859, 0.429522, -0.094128, 0.404736, -0.074916, -0.039387, 1.404768, 0.806075, -0.618665, -0.524814, -1.687255, -1.510430, -1.072294, -0.246813, -0.073978, 0.787083, 1.811741, 0.813399, 0.725950, 0.512732, -0.238496, 1.858489, 0.408433, -0.034156, -0.331392, -2.818352, -2.478919, -1.911989, -0.978855, -0.082908, 0.136750, 1.760895, 1.271401, 0.765704, 0.646747, -0.227449, 1.083950, -0.378959, -1.028250, -1.271867, -3.429653, -3.367459, -2.418019, -1.765727, -0.048931, -0.207872, 0.318775, 1.042545, 0.925654, 0.137993, -0.360010, -0.049747, 0.307798, -1.612398, -1.734037, -1.511951, -2.462113, -2.401482, -1.917172, 0.001560, -0.110547, -0.064077, 0.102384, 0.383601, 0.038955, -0.626877, -0.546325, -1.273145, -1.591001, -3.276381, -1.707828, -1.369150, -2.344973, -0.979318, 0.025571, -0.068086, -0.110815, -0.275657, -0.633743, -0.176045, -1.059053, -1.292179, -2.138340, -1.398783, -0.579958, -1.274659, 0.251483, 0.129816, -0.017892, -0.013944, -0.055661, -0.148589, -0.228916, -0.495239, -0.055228, -0.281131, -0.956149, -1.516872, -0.425082, 0.417799, -0.176763, 0.393657, 1.677535, -0.011750, -0.003095, 0.017573, -0.052273, -0.174919, -0.147411, -0.200392, -0.185715, -1.245828, -2.415545, -2.435377, -2.191895, -0.708249, -0.444342, 1.246045, 0.001669, 0.017330, -0.084566, -0.090203, -0.123243, -0.507070, -0.668548, -0.247910, -0.331670, -1.904029, -2.914813, -2.425534, 0.080178, 0.358506, 0.583318, -0.011229, 0.029371, -0.046960, -0.073925, -0.048650, -0.367188, -0.932504, -1.412060, -1.804139, -2.872730, -0.624699, -1.205847, 0.448142, 1.139165, 0.182123, -0.010781, 0.037707, -0.033327, -0.054006, -0.073760, -0.090311, -0.091450, -0.348807, -1.036500, -1.162360, 0.164093, -0.118403, -0.054556, 0.719941, 0.191468, -0.018306, -0.003601, -0.001027, -0.060051, 0.008672, -0.039604, -0.211722, -0.706412, -1.133769, 0.003691, 0.341601, 0.074682, -0.217264, 0.956250, -0.015056, -0.010774, -0.021539, -0.000992, -0.046828, -0.105236, -0.069223, -0.092283, -0.640155, -0.261814, 1.206264, 0.931755, 0.885600, 1.327787, 1.612729, -0.190890, -0.008274, -0.020355, -0.037037, -0.047850, -0.107079, -0.082944, -0.571642, -0.759736, -0.268327, 1.366006, 1.504999, 2.423352, 3.055692, 0.933010, -0.145648, 0.008046, -0.040349, -0.010758, -0.000754, -0.049316, -0.256091, -0.399648, 0.758664, 2.422193, 2.686339, 3.334860, 1.415180, 0.200351, -0.039762, -0.095791, -0.002586, -0.011867, -0.000871, -0.000565, -0.000891, 0.005375, -0.007311, -0.073475, -0.007792, -0.004774, -0.008627, -0.013238, -0.022900, -0.041760, -0.024964, -0.000495, -0.006615, -0.002792, -0.000378, -0.007787, -0.010185, 0.121740, -0.053601, -0.007677, -0.007010, -0.006062, -0.020857, -0.021306, -0.007363, 0.000612, 0.000028, 0.007030, -0.003897, -0.001694, -0.021140, -0.011261, -0.006511, -0.029172, -0.006649, -0.008782, -0.015368, -0.005023, 0.051567, 0.000028, 0.000738, 0.000000};


float adult_weights[(ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT) + 1] =
//{-1.209400, -0.487470, -0.556039, -0.679246, -0.546923, -0.537443, -0.697640, -0.585580, -0.639547, -0.632441, -0.626519, -0.314476, -0.354330, -0.453712, -0.404184, -0.399919, -0.495095, -0.455387, -0.361320, -0.272204, -0.267332, -0.302766, -0.457391, -0.536931, -0.510839, -0.442906, -0.294470, -0.238306, -0.300144, -0.425352, -0.483960, -0.343784, -0.368726, -0.534778, -0.320217, -0.494357, -0.635549, -0.445605, -0.437267, -0.264338, -0.308579, -0.335765, -0.373622, -0.428324, -0.309677, -0.539069, -0.184885, -0.270676, -0.362003, -0.357752, -0.517873, -0.441009, -0.376894, -0.365490, -0.314999, -0.296691, -0.443987, -0.423059, -0.586182, -0.398150, -0.567661, -0.184620, -0.181703, -0.351853, -0.421455, -0.443544, -0.516684, -0.497662, -0.463474, -0.372101, -0.473927, -0.551342, -0.469956, -0.638985, -0.516752, -0.506557, -0.345928, -0.362528, -0.500065, -0.407387, -0.516400, -0.382696, -0.426540, -0.441100, -0.518102, -0.597026, -0.503292, -0.412286, -0.536468, -0.488852, -0.489199, -0.431149, -0.466127, -0.603378, -0.387418, -0.402346, -0.432992, -0.250855, -0.389966, -0.608647, -0.459779, -0.419184, -0.300038, -0.589740, -0.437518, -0.444065, -0.455911, -0.413065, -0.354975, -0.432819, -0.516877, -0.432761, -0.374958, -0.516863, -0.572199, -0.411160, -0.461132, -0.303748, -0.521696, -0.445356, -0.440774, -0.368366, -0.470754, -0.699706, -0.603472, -0.583469, -0.540718, -0.514824, -0.525724, -0.646857, -0.479432, -0.574671, -0.371771, -0.529877, -0.440406, -0.457029, -0.637935, -0.559076, -0.578541, -0.637386, -0.709403, -0.676427, -0.681189, -0.625741, -0.768070, -0.578781, -0.704729, -0.575381, -0.577986, -0.493144, -0.513094, -0.609000, -0.534391, -0.751153, -0.744115, -0.784344, -0.472062, -0.463585, -0.383175, -0.472053, -0.420214, -0.579845, -0.595712, -0.606567, -0.582932, -0.698447, -0.621826, -0.717730, -0.762557, -0.695326, -0.586874, -0.284184, -0.056877, 0.067131, 0.011677, -0.043039, -0.156306, -0.175707, -0.562692, -0.599360, -0.721575, -0.726328, -0.728221, -0.645294, -0.663595, -0.380991, -0.155960, 0.216848, 0.622864, 0.557300, 0.483398, 0.212543, 0.017833, -0.050468, -0.466223, -0.688767, -0.720014, -0.689748, -0.668687, -0.688362, -0.498032, -0.472473, -0.423033, 0.204857, 0.106368, -0.014206, 0.008199, -0.463471, -0.282168, -0.656857, -0.785179, -0.802000, -0.790217, -0.636979, -0.586424, -0.415213, -0.294989, -0.362516, -0.056852, 0.112676, -0.152857, -0.322391, -0.509879, -0.402580, -0.636741, -0.920162, -0.851213, -0.769778, -0.347020, -0.543050, 0.021342, 0.493590, 0.463944, 0.650013, 0.534232, 0.607077, 0.577856, 1.574257, 0.914622, 0.712605, -0.145156, -0.959030, -0.983801, -0.657962, -0.430179, 0.528919, 0.716066, 0.226484, 0.267270, -0.186949, 0.191484, 0.132084, 0.313387, 0.680460, 0.206641, 0.869824, -0.780066, 2.101629, 0.752718, 0.135683, -0.233669, 0.106290, 0.490188, 0.302152, -0.000294, -0.142011, -0.258921, -0.599163, -0.587321, -0.730186, -0.874963, 0.579254, 2.011884, -0.774772, 0.479256, -0.190688, -0.239314, 0.077739, 0.155068, -0.129083, -0.536219, -0.669671, -0.621382, -0.708950, -0.760751, -1.000326, 1.415829, 5.108424, -0.454691, 1.214852, -0.465907, -0.122900, 0.366517, 0.756383, 0.225433, -0.176414, -0.521628, -0.525823, -0.544263, -0.767282, -0.952655, -0.528198, 3.655444, 2.169842, -0.139575, -0.670316, -0.287407, -0.187097, 0.410103, 0.219467, -0.263921, -0.445426, -0.658485, -0.484530, -0.925472, -0.900433, -0.494267, -0.382149, -0.523106, 0.015914, -0.656768, -0.357988, -0.558182, 0.086141, 0.029480, -0.520004, -0.483367, -0.530464, -0.572152, -0.895663, -0.846631, 0.249486, -0.261926, -0.565480, 0.264540, -0.525442, -0.299701, -0.329461, 0.107264, -0.185674, -0.615083, -0.679398, -0.700439, -0.404662, -0.968065, -0.812446, 0.285666, 0.019804, -0.389351, 0.083863, 0.005396, 0.028934, 0.276546, 0.019592, -0.223955, -0.499491, -0.708066, -0.646136, -0.569928, -0.873470, -0.372208, -0.179357, 0.123683, -0.309342, -0.429034, 0.686583, 0.939239, 0.941857, 0.559291, 0.904640, 0.767990, 0.764736, 1.010736, 1.859177, 0.916096, 1.281349, -0.155223, 0.031527, -0.136996, -0.678074, -0.579714, -0.224072, -0.155569, -0.043834, 0.628193, 0.429106, -0.067318, 1.577975, 1.204944, -0.821272, -0.756002, -0.391339, 0.003846, 0.084494, -0.559991, -0.513987, -0.368228, -0.462115, -0.418843, -0.020405, 0.522799, -0.135540, 1.868241, 1.321117, -0.931532, -0.743147, -0.094063, 0.292839, -0.328662, -0.544517, -0.708300, -0.352683, -0.808206, -0.576620, -0.271041, 0.067842, 0.856721, -0.036901, 0.188020, -0.918353, -0.852331, 0.003424, -0.110340, 0.023035, -0.301187, -0.462718, -0.315611, -0.416110, -0.397396, -0.767729, 0.077089, 1.071688, -0.386690, 0.328878, -0.959684, -0.892254, -0.021844, -0.296731, 0.025689, -0.334430, -0.450487, -0.358902, -0.783287, -0.611485, -0.709260, 0.030284, 1.439679, 1.425589, 0.776668, -0.933410, -0.755823};
{-3.265594, -0.430844, -0.717710, -0.896156, -0.658513, -0.559208, -0.350668, -0.117357, -1.243414, -0.757566, -0.411743, -0.212033, -0.870858, -0.453170, 0.742589, 2.263852, 1.839834, 1.555978, 1.473942, 1.024452, 0.807335, 0.558465, 0.209828, 0.018484, -0.003893, 1.314594, 1.018005, 1.665532, 3.286150, 3.785002, 4.491933, 5.612357, 3.824594, 2.449087, 1.525652, 0.912039, 0.243650, 0.357340, 0.184585, 0.124314, 0.998164, 0.204343, 0.722394, 0.752752, 1.391942, 2.236456, -0.830318, -0.698188, -0.018413, -0.862049, -0.741793, -0.691929, -0.855908, -0.243530, -0.756373, -0.247284, -1.017125, -0.618397, -0.639072, -0.574544, -0.472652, -0.514506, -0.397054, -0.182930, -0.186941, -0.469240, -0.293686, -0.456168, 0.223971, -0.116395, 0.198481, -0.532476, -0.198401, -0.201876, -0.220371, -0.068350, -0.688436, -0.278092, -0.276134, -0.069793, -0.339688, -0.557977, -0.551317, 0.657693, -0.454165, 0.089850, -0.614573, -0.896176, -0.533196, -0.557121, -0.382444, 0.103264, -0.114877, -0.147897, -0.199980, -0.109554, -0.563231, -0.480691, 0.456616, -0.389936, -0.186795, -0.393763, -0.604631, -0.503348, -0.592132, -0.226609, 0.079957, 0.240437, 0.581848, 0.354573, 0.452593, 0.028180, 0.117612, 0.199611, -0.354688, -0.466944, -0.398202, -0.248629, 0.339816, -0.022426, -0.617622, -0.119730, -0.565152, -0.419751, -0.095240, 0.918274, 0.218659, -0.139567, -0.242320, -0.493782, -0.208200, 0.814606, -0.349409, 0.356784, 0.931150, 1.122111, 1.193713, 0.927492, 1.034929, 0.421903, 0.253443, 0.223407, 0.033319, -0.250397, 0.561796, -0.037999, -0.055216, 0.515640, 0.658522, 0.536616, -0.534281, -0.042413, -0.099949, -0.436816, -0.586824, -0.240590, -0.227657, 0.070791, 0.452576, 0.796884, 1.999830, 0.417303, 1.120605, 1.171486, 0.779106, -0.456753, -0.548985, -0.637358, -0.870028, -0.764627, -0.290220, 0.258816, 1.187137, 2.195950, 1.377536, 2.098046, 0.179262, 1.093252, 0.409152, 1.245365, -0.607239, -0.777497, -0.787465, -1.268521, -1.354344, 0.069902, 0.729885, 0.928415, 0.887472, 0.382325, 0.594495, -0.429897, 0.892156, 0.284757, 1.532653, -0.557396, -0.860489, -0.931289, -1.061067, -0.982274, -0.925265, -0.289025, 0.413722, 0.143555, 1.043954, -0.797077, 0.230904, 1.326969, 1.495481, 2.456306, -0.339701, -0.791899, -0.786732, -0.302882, 0.065101, -0.608166, 0.335491, 0.041720, -0.048888, 1.333673, 0.166007, 0.504059, 1.119984, 1.513837, 2.278356, 0.027025, -0.800848, -0.699428, -0.635285, -0.169030, -0.520872, -0.552060, -0.506593, -0.690224, 0.872636, 1.329964, 0.420289, 1.940619, 1.700129, 2.014569, -0.069389, -0.473786, -0.903431, -0.895943, -0.234741, -0.403265, -0.857102, -0.228942, -0.003523, 1.412163, 0.672384, 0.936789, 2.045572, 1.146349, 1.897806, 0.047054, -0.441458, -0.909807, -0.975864, -0.548420, -0.032136, 0.282662, 1.030997, 0.636681, 0.596753, -0.897007, 0.027807, 0.318776, 0.343058, 1.597327, 0.342642, -0.451186, -0.791217, -0.711435, -0.633803, 0.081798, 0.697299, 0.734632, -0.638951, -0.777263, -1.185054, 0.008696, -0.163929, 0.468595, 1.696041, -0.186912, -0.664923, -0.588911, -0.745572, -0.711196, -0.649798, 0.764110, 1.000405, -0.033423, 1.934924, 1.656934, 1.592363, 0.702569, 0.405546, 1.498664, -0.293384, -0.570051, -0.404199, -0.525971, -0.565838, -0.595840, 0.660991, 0.195334, 1.714752, 0.386222, 0.883229, 0.914149, 0.465003, -0.316270, 1.420656, -0.388258, -0.508149, -0.538746, -0.608623, -0.868401, -0.448630, 0.413143, 0.815386, 1.895990, -0.074992, -0.952812, -0.576774, -1.389414, -0.605110, 1.359090, -0.551421, -0.465257, -0.556020, -0.874455, -0.762905, -0.496263, 0.394307, -0.249437, 0.748168, -0.284663, -0.583728, -0.526375, -1.190380, -0.003951, 1.284831, -0.662087, -0.620332, -0.733920, -0.612966, -0.634924, -0.432354, 0.171906, -0.236586, 0.571425, 0.768687, 0.465102, -0.019607, -0.523269, 0.398626, 1.013636, -0.629656, -0.477629, -0.795466, -0.658820, -0.500217, -0.064383, -0.168470, 0.404761, 2.516735, 0.782910, 0.796316, 0.709364, 0.416625, 0.544177, 0.971460, -0.573472, -0.483294, -0.259271, 0.013393, -0.341221, 0.599878, 1.953348, 2.600861, 3.353471, 2.170324, 2.496132, 1.262117, 2.005809, 0.966800, 1.220711, -0.118749, -0.220437, -0.294186, 0.003246, 0.099139, 0.364636, -0.084551, 0.400219, 0.411693, 0.467075, 0.447767, 1.167907, 0.751806, -0.195655, 0.535028, -0.868593, -0.419945, -0.483661, -0.400436, -0.426888, -0.428455, -0.565987, -0.271022, -0.819305, -1.184475, -1.222693, -0.909211, -1.120087, -1.083301, 0.084613, -1.055727, -0.520872, -0.450193, -0.420499, -0.477602, -0.484702, -0.397058, -0.279848, -0.726816, -1.109658, -1.070709, -0.939025, -0.998046, -1.037870, 0.092666, -1.239824, -0.573156, -0.443877, -0.492533, -0.478718, -0.490457, -0.559602, -0.177752, -0.532088, -0.767008, -1.128890, -0.713416, -0.640088, -0.882997, -0.108082, -1.234641};
//{-1.203768, -0.221084, -0.265705, -0.310677, -0.288682, -0.199489, -0.065266, -0.162320, -0.550889, -0.251863, 0.154790, 0.119811, -0.182671, -0.059630, 0.370035, 0.948770, 0.976598, 0.922593, 0.818677, 0.596665, 0.491212, 0.289885, -0.040096, -0.033785, 0.119548, 1.068540, 0.767295, 1.046392, 1.550828, 1.950520, 2.262869, 2.687480, 2.196747, 1.511412, 0.964990, 0.582628, 0.075931, 0.042621, 0.085799, 0.225413, 0.931166, 0.453570, 0.570324, 0.575185, 1.029131, 1.330769, -0.358854, -0.283600, 0.110725, -0.292491, -0.296356, -0.328253, -0.490708, -0.138456, -0.229086, 0.247543, -0.255718, -0.141032, -0.130023, -0.078071, -0.083539, -0.161165, -0.103975, 0.047289, 0.091935, -0.214972, -0.217788, -0.302081, 0.025599, -0.026801, 0.395482, -0.129882, 0.016613, 0.037313, 0.020742, 0.012230, -0.270509, -0.117016, -0.075404, 0.105864, -0.135838, -0.307252, -0.306705, 0.182349, -0.097166, 0.338002, -0.200036, -0.202042, -0.043861, -0.118298, -0.092333, 0.069640, -0.009472, -0.028739, 0.017167, 0.016745, -0.268285, -0.240396, 0.116585, 0.074884, 0.174595, -0.147040, -0.072381, 0.001382, -0.130802, 0.016387, 0.092699, 0.191334, 0.303882, 0.262606, 0.357353, 0.013996, 0.081581, 0.029622, 0.092600, 0.051173, -0.048770, 0.118018, 0.359950, 0.194600, -0.117385, -0.052252, -0.181105, -0.150316, 0.003519, 0.525894, 0.157999, 0.019991, -0.143675, 0.058681, 0.192065, 0.513001, 0.111797, 0.365392, 0.636598, 0.667130, 0.489641, 0.371651, 0.432312, 0.196652, 0.118982, 0.144200, 0.112701, -0.152247, 0.457224, 0.318043, 0.079528, 0.394645, 0.472596, 0.441441, -0.095533, -0.032004, -0.103071, -0.234904, -0.224812, -0.044159, -0.065624, 0.134157, 0.153858, 0.347792, 1.401629, 0.288945, 0.508501, 0.640729, 0.498019, -0.123418, -0.268517, -0.341920, -0.447672, -0.359105, -0.124434, 0.167357, 0.694336, 1.043567, 0.741832, 1.589573, 0.214716, 0.488855, 0.300023, 0.716698, -0.156762, -0.372528, -0.398698, -0.686088, -0.659573, 0.038228, 0.417341, 0.574864, 0.459172, 0.491077, 0.797475, -0.045548, 0.512488, 0.248543, 0.845213, -0.151898, -0.422939, -0.454729, -0.567704, -0.497626, -0.529828, -0.139140, 0.264012, 0.218611, 0.996101, -0.018708, 0.319710, 0.831819, 0.909897, 1.294751, -0.047960, -0.389608, -0.399505, -0.130087, 0.057588, -0.321499, 0.088129, 0.025913, 0.166625, 1.132955, 0.431834, 0.410929, 0.888851, 0.874743, 1.185054, 0.089117, -0.398209, -0.351880, -0.277398, -0.047328, -0.243128, -0.221667, -0.266676, -0.155701, 0.874946, 1.101795, 0.372763, 1.152882, 0.848754, 1.118283, -0.044684, -0.254499, -0.445632, -0.420321, -0.024606, -0.153919, -0.384677, -0.150049, 0.160820, 1.180195, 0.727041, 0.622093, 1.147777, 0.518762, 1.077881, -0.038596, -0.239271, -0.457999, -0.510096, -0.235954, -0.028982, 0.076047, 0.593702, 0.545588, 0.751247, -0.030759, 0.145533, 0.278809, 0.173440, 0.957457, 0.061596, -0.246815, -0.434456, -0.410036, -0.311181, 0.046367, 0.343550, 0.515021, -0.053179, 0.038779, -0.218808, 0.199723, -0.043322, 0.228095, 1.026768, -0.056341, -0.363293, -0.340503, -0.394753, -0.339807, -0.283253, 0.437225, 0.557720, 0.265178, 1.549164, 1.026754, 0.936345, 0.151181, 0.199812, 0.942867, -0.051543, -0.328999, -0.248672, -0.281815, -0.249771, -0.247084, 0.304312, 0.253784, 1.380706, 0.741920, 0.666430, 0.507127, 0.067443, -0.095904, 0.865663, -0.099796, -0.287391, -0.312084, -0.305587, -0.387437, -0.224757, 0.232100, 0.668650, 1.465527, 0.245212, -0.218772, -0.195081, -0.554432, -0.269176, 0.830376, -0.151771, -0.243892, -0.299768, -0.439108, -0.347744, -0.223303, 0.271381, 0.118781, 0.744320, 0.200099, 0.054767, -0.116328, -0.425326, 0.007845, 0.778705, -0.178524, -0.292237, -0.351712, -0.302628, -0.249456, -0.187193, 0.236319, 0.155706, 0.634810, 0.726284, 0.582479, 0.154226, -0.130600, 0.222551, 0.700642, -0.164803, -0.221211, -0.363830, -0.283649, -0.159439, 0.028860, 0.057137, 0.522399, 1.694631, 0.663407, 0.636724, 0.394405, 0.188624, 0.334175, 0.693858, -0.171639, -0.221637, -0.155767, -0.034147, -0.122447, 0.192638, 1.066319, 1.700986, 2.067010, 1.287166, 1.429227, 0.494613, 0.728523, 0.569097, 0.687570, -0.048233, -0.092949, -0.147212, -0.072610, -0.033890, 0.023569, -0.050739, 0.316192, 0.363634, 0.363651, 0.182992, 0.423642, 0.309029, -0.030928, 0.487938, -0.261174, -0.198829, -0.209889, -0.146738, -0.165562, -0.148730, -0.185910, 0.021419, -0.205469, -0.319893, -0.385965, -0.348342, -0.387918, -0.310486, 0.374173, -0.332322, -0.206207, -0.210088, -0.164681, -0.182703, -0.183087, -0.105169, 0.005308, -0.199610, -0.340872, -0.405699, -0.350182, -0.365992, -0.293995, 0.343619, -0.387651, -0.231144, -0.196011, -0.175335, -0.165242, -0.174265, -0.175227, 0.026155, -0.175107, -0.293330, -0.436530, -0.323608, -0.260217, -0.260268, 0.265616, -0.389364};




//int big_doll_front_data[(ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT)]  =  {0,0,0,0,1,9,0,1,9,0,0,0,0,0,0,
//                                                                        0,0,0,0,1,9,0,1,9,0,0,0,0,0,0,
//                                                                        0,0,0,0,1,8,0,1,1,0,0,0,0,0,0,
//                                                                        0,0,0,0,1,9,0,1,9,9,0,0,0,0,0,
//                                                                        0,0,0,0,1,9,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,0,1,9,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,0,1,1,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,0,1,1,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,0,1,1,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,0,1,1,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,9,1,1,9,1,1,9,0,0,0,0,0,
//                                                                        0,0,0,4,4,2,9,5,1,9,6,0,0,0,0,
//                                                                        0,0,0,2,3,4,5,6,3,6,9,9,1,9,0,
//                                                                        0,0,4,2,2,4,5,6,7,3,9,1,1,9,0,
//                                                                        0,0,1,9,3,2,9,7,1,3,8,1,8,0,0,
//                                                                        0,0,2,8,1,1,0,0,4,9,9,1,9,0,0,
//                                                                        0,0,2,2,8,1,1,5,7,8,9,1,8,0,0,
//                                                                        0,0,2,1,8,3,1,3,9,8,8,1,7,0,0,
//                                                                        0,0,2,1,9,8,1,2,9,9,1,8,0,0,0,
//                                                                        0,0,0,2,9,9,3,7,6,9,1,8,0,0,0,
//                                                                        0,0,0,1,1,9,2,5,4,9,8,9,0,0,0,
//                                                                        0,0,0,1,1,9,1,5,5,8,7,0,0,0,0,
//                                                                        0,0,0,0,2,8,4,1,6,6,8,0,0,0,0,
//                                                                        0,0,0,0,1,1,9,1,3,9,9,0,0,0,0,
//                                                                        0,0,0,0,3,1,9,3,7,9,9,0,0,0,0,
//                                                                        0,0,0,0,0,2,9,4,8,7,8,0,0,0,0,
//                                                                        0,0,0,0,0,2,3,3,8,8,7,0,0,0,0,
//                                                                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//                                                                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//                                                                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};





short O_GetDistance(short row_,ITS *iTS)
{
    short distance = 0;
	double H_V=0;

	row_=LimitVP(row_);
    H_V = EV_ROAD_SLOPE - (double)(row_ - iTS->F_H_C + 1);

	if(H_V != 0)
	{
        distance = (short)(((double)22.8/*S_HOCam*//H_V) * (double)S_ev);
	}
	if(distance < 0)
		return 0;
	else
		return distance;
}

short O_GetRowDistance(short distance,ITS *iTS)
{
	short row;
    double temp = 0;
    temp = EV_ROAD_SLOPE - 22.8;//S_HOCam;
        temp = (temp/((double)distance - 0))*(double)S_ev;
	if(temp < 0)
		temp = -temp;
    row = (iTS->F_H_C - (short)temp );
	return row;
}

short O_GetRowDistanceBetweenRowAndRow(short distance, short row_, ITS *iTS)
{
    short row_distance =0;
    short final;

    row_distance = O_GetDistance(row_,iTS);
    row_distance += distance;
    row_distance = O_GetRowDistance(row_distance, iTS);
    final = row_distance - row_;
    if(final < 1)
        final = 1;
    return final;
}

short O_GetRow_(short distance,ITS *iTS)
{
	double H_V;
	if(distance<O_RD_MinDistanceOfAlgorithm)
		distance = O_RD_MinDistanceOfAlgorithm;
	H_V = S_HOCam*S_ev/(double)distance;
	return LimitVP((short)(iTS->O_evRodSlp-H_V+iTS->F_H_C+0.5));
}

short O_DItoDW(short value,short row_,ITS *iTS)
{
	double Vrow=iTS->O_evRodSlp - (LimitVP(row_) - iTS->F_H_C + 1 );
	return DItoDW(value,Vrow);
}

short O_DWtoDI(short value,short row_,ITS *iTS)
{
    //double Vrow = 0 - (LimitVP(row_) - iTS->F_H_C + 1 );
    double Vrow = EV_ROAD_SLOPE - (LimitVP(row_) - iTS->F_H_C + 1 );
	return DWtoDI(value,Vrow);
}

void W_SetObstacleWarring(ITS *iTS)
{
		//Safe distance
		if(iTS->CARM.RealDistance > O_WARNING_DISTANCE)
		{
			iTS->W_Obstacle = SafeDistance;
		}
		//Warning distance
		if(iTS->CARM.RealDistance < O_WARNING_DISTANCE && iTS->CARM.RealDistance > O_DANGEROUS_DISTANCE)
		{
			iTS->W_Obstacle = WarningDistance;
		}
		//Dangerous distance
		if(iTS->CARM.RealDistance < O_DANGEROUS_DISTANCE)
		{
			iTS->W_Obstacle = DangerousDistance;
		}		
}

void DistanceSmoothing(SECTION_ *sec,ITS *iTS)
{
	short NewDistance=0;
	short OldDistance=0;
	short Difference=0;

	if(sec->CarInfo.Ctype==None)
	{
		sec->RealDistance=0;
		return ;
	}
	NewDistance = O_GetDistance(sec->CarInfo.Position.BB,iTS);
	if(NewDistance<0)
	{
		sec->RealDistance=0;
		return ;
	}
	if(sec->StableCtr<O_FC_GoingStable)
	{
		sec->RealDistance=NewDistance;
		return ;
	}
	OldDistance = iTS->CAR->RealDistance;
	Difference = NewDistance-OldDistance;
	if(Difference > O_RL_MaxDiffDistance)
		iTS->CAR->RealDistance += O_RL_MaxDiffDistance;
	else if(Difference < -O_RL_MaxDiffDistance)
		iTS->CAR->RealDistance -= O_RL_MaxDiffDistance;	
	else
		iTS->CAR->RealDistance=(NewDistance+iTS->CAR->RealDistance*7)>>3;
}

void O_ClearSection(SECTION_ *sec)
{
	char CarSign=sec->CarSign;
	memset(sec,0,sizeof(SECTION_));
	V_CleanCarInfo(&sec->CarInfo);
	sec->CarSign=CarSign;
}

#ifdef VEHICLE_VERIFY_SYMMETRY_PROCESS_ON_OFF
//Symmetry axis calculation
//#define DRAW_DEBUG_INFORMATION
#define F_V_VEHICLE_VERIFY_SYMMETRY_MAXIMUM_INTEGER		4294967295
#define F_V_VEHICLE_SYMMETRY_THRESHOLD	5
//#define F_V_DISPLAY_VEHICLE_VERIFY_SYMMETRY_AXIS
short F_V_VehicleVerifySymmetryProcess(ITS *iTS)
{
	short row = 0;
	short column = 0;

	short row_start = iTS->CAR->CarInfo.Position.BB;
	short row_end = iTS->CAR->CarInfo.Position.TB;
	//short row_end = iTS->CAR->CarInfo.Position.BB + (iTS->CAR->CarInfo.Position.BH >> 1);
	short column_start = iTS->CAR->CarInfo.Position.LB + (iTS->CAR->CarInfo.Position.BW >> 2);
	short column_end = iTS->CAR->CarInfo.Position.RB - (iTS->CAR->CarInfo.Position.BW >> 2);
	short column_shift = 0;
	short half_width = (column_end - column_start) >> 1;
	short symmetry_axis = 0;	

	unsigned int process_position = 0;
	unsigned int process_row = SinkDataIndexStart(iTS->CAR->CarInfo.Position.BB);
	unsigned int minimum_value = F_V_VEHICLE_VERIFY_SYMMETRY_MAXIMUM_INTEGER;

	unsigned int symmetry_array[S_IMGW] = {0};

	if(column_start <= 0 || column_end <= 0)
	{
		return 0;
	}
	if(column_start < S_IMGLB)
	{
		return 0;
	}
	if(column_end > S_IMGRB)
	{
		return 0;
	}

	for(row = row_start; row < row_end; row ++)
	{
		process_row = SinkDataIndexNextRow(process_row);

		for(column = column_start; column < column_end; column ++)
		{
			process_position = process_row + column;

			for(column_shift = 1; column_shift <= half_width; column_shift ++)
			{
				if(column - column_shift < S_IMGLB)
				{
					symmetry_array[column] += (unsigned int)(iTS->YImg[process_position + column_shift] - 0);
				}
				else if(column - column_shift > S_IMGRB)
				{
					symmetry_array[column] += (unsigned int)(iTS->YImg[process_position + column_shift] - 0);
				}
				else if(column + column_shift < S_IMGLB)
				{
					symmetry_array[column] += (unsigned int)(iTS->YImg[process_position - column_shift] - 0);
				}
				else if(column + column_shift > S_IMGRB)
				{
					symmetry_array[column] += (unsigned int)(iTS->YImg[process_position - column_shift] - 0);
				}
				else
				{
					symmetry_array[column] += (unsigned int) 
						abs(iTS->YImg[process_position + column_shift] - iTS->YImg[process_position - column_shift]);
				}
			}
		} 
	}

	for(column = column_start; column < column_end; column ++)
	{
		if(symmetry_array[column] > 0 && symmetry_array[column] < minimum_value)
		{
			minimum_value = symmetry_array[column];
			symmetry_axis = column;
		}
	}



#ifdef F_V_DISPLAY_VEHICLE_VERIFY_SYMMETRY_AXIS
	OSD_Color_Setup(OCN_RED, iTS);   
	DrawRectangle(row_start, row_end, column_start + half_width, column_start + half_width, iTS); 
	DrawRectangle(row_start, row_end, column_start, column_end, iTS); 
	OSD_Color_Setup(OCN_PURPLE, iTS);   
	DrawRectangle(row_start, row_end, symmetry_axis, symmetry_axis, iTS); 


	OSD_Color_Setup(OCN_WHITE, iTS);
	DrawBar(S_IMGH- row_start - 17, column_start - 2, 15, 30, iTS);
	OSD_Color_Setup(OCN_BLACK, iTS);
	ScalableNumber((short) abs((int)(symmetry_axis - (column_start + half_width))), 2, column_start, S_IMGH- row_start - 15, iTS);	
#endif

	
	if(symmetry_axis != 0 && (abs((int)(symmetry_axis - (column_start + half_width))) > F_V_VEHICLE_SYMMETRY_THRESHOLD))
	{

#ifdef DRAW_DEBUG_INFORMATION
		OSD_Color_Setup(OCN_RED, iTS);	
		DrawRect_Has_UV(6, 46, 20, iTS);
#endif
		return 0;
	}

#ifdef DRAW_DEBUG_INFORMATION	
	OSD_Color_Setup(OCN_GREEN, iTS);
	DrawRect_Has_UV(6, 46, 20, iTS);
#endif

	return 1;
}
#endif

short O_Main(ITS *iTS)
{
	//Initial Fuzzy Array
	short i = 0, j = 0;

	iTS->V_tail_edge_one_time_flag = 0;
	
	for(i = 0; i <= N_MaxPairGroup; i++)
	{
		for(j = 0; j <= N_AllFeature; j++)
		{
			iTS->O_FZ_PVEInfo[i][j] = 0;
			iTS->O_FZ_Feature[i][j] = 0;
		}
	}

	memset(iTS->L_ColProjection, 0, S_IMGW * S_IMGH * sizeof(char));
   	memset(iTS->O_SD_VerPrjArray, 0, S_IMGW * sizeof(short));
	memset(iTS->O_VE_VP_Array, 0, S_IMGW * sizeof(short));
	memset(iTS->O_HD_Array, 0, S_IMGH * sizeof(short));
   	memset(iTS->O_CL_Array, 0, S_IMGH * sizeof(short));

	iTS->O_Distance = 0;
	
#ifdef L_DRAW_LAND_BOUND_ON_OFF
	L_DrawLandBnd(iTS->Showimage,iTS);
#endif

#ifdef O_DRAW_LAND_BOUND_ON_OFF
	O_DrawLandBnd(iTS->Showimage,iTS);
#endif

	iTS->O_LaneBound= iTS->O_LaneMBound;

//    if(iTS->function_switch.stop_line_detection == 1)
//        O_FindHorizontalLine(iTS);
//	iTS->CAR = &iTS->CARM;
//	O_FindObstacle(iTS);

    O_PedestrianDetection(iTS);


//    O_CandidateTrainingData(S_IMGCW, L_IB_BB_SearchLane + 10, ADULT_DETECT_WIDTH, ADULT_DETECT_HIGHT, iTS); //in cm
//    O_CandidateTrainingData(S_IMGCW, L_IB_BB_SearchLane + 10, CHILD_DETECT_WIDTH, CHILD_DETECT_HIGHT, iTS); //in cm
//    O_Training_LR_Datan(S_IMGCW + 50, L_IB_BB_SearchLane + 10, ADULT_DETECT_WIDTH, ADULT_DETECT_HIGHT, iTS); //in cm
 //  O_Training_LR_Datan(S_IMGCW + 50, L_IB_BB_SearchLane + 10, CHILD_DETECT_WIDTH, CHILD_DETECT_HIGHT, iTS); //in cm



//    O_Training(S_IMGCW, L_IB_BB_SearchLane + 10, ADULT_DETECT_WIDTH, ADULT_DETECT_HIGHT, iTS); //in cm
//    O_Training(S_IMGCW, L_IB_BB_SearchLane + 10, CHILD_DETECT_WIDTH, CHILD_DETECT_HIGHT, iTS); //in cm
//    O_TrainingCandidate(S_IMGCW, L_IB_BB_SearchLane + 10, ADULT_DETECT_WIDTH, ADULT_DETECT_HIGHT, iTS); //in cm

//    O_TrainingCandidate(S_IMGCW, L_IB_BB_SearchLane + 10, CHILD_DETECT_WIDTH, CHILD_DETECT_HIGHT, iTS); //in cm


//	F_V_DetectionDayOrNight(S_IMGH - 25, S_IMGH - 5, S_IMGCW - 20, S_IMGCW + 20, iTS);

#ifdef SHOW_VEHICLE_SHADOW_AND_LIGHT_TH
	OSD_Color_Setup(OCN_GREEN, iTS);
	ScalableNumber((short) iTS->O_SD_ShadowTh, 4, (S_IMGW >> 1) - 130, 60, iTS);
	ScalableNumber((short) iTS->O_CarLightTH, 4, (S_IMGW >> 1) + 100, 60, iTS);
#endif

#ifdef O_SHOW_OBSTACLE_STBCOUNTER_AND_CLASS       
	OSD_Color_Setup(OCN_GREEN, iTS);     
	ScalableNumber((short) iTS->CAR->StableCtr, 4, (S_IMGW >> 1) - 130, 90, iTS);
	ScalableNumber((short) iTS->CAR->CarInfo.Ctype, 4, (S_IMGW >> 1) + 100, 90, iTS);
#endif
	
#ifdef O_FZ_PVE_INFORMATION_DISPLAY
	OSD_Color_Setup(OCN_RED, iTS);
	ScalableNumber((short) iTS->O_Distance, 2, (S_IMGW>>1)-30, S_IMGH-60, iTS);
	ScalableNumber((short) iTS->O_BridgeShadow, 2, (S_IMGW>>1)+10, S_IMGH-60, iTS);
	ScalableNumber((short) iTS->O_VE_VP_PairGroupNum, 2, (S_IMGW>>1)+40, S_IMGH-60, iTS);
   	ScalableNumber((short) iTS->O_FZ_PVEInfo[0][VE_], 2, (S_IMGW>>1)-60, S_IMGH-40, iTS);
	ScalableNumber((short) iTS->O_FZ_PVEInfo[0][CL_], 2, (S_IMGW>>1)-30, S_IMGH-40, iTS);
	ScalableNumber((short) iTS->O_FZ_PVEInfo[0][SD_], 2, (S_IMGW>>1), S_IMGH-40, iTS);
	ScalableNumber((short) iTS->O_FZ_PVEInfo[0][BB_], 2, (S_IMGW>>1)+30, S_IMGH-40, iTS);
	ScalableNumber((short) iTS->O_FZ_PVEInfo[0][HE_], 2, (S_IMGW>>1)+60, S_IMGH-40, iTS);
	ScalableNumber((short) iTS->O_FZ_PVEInfo[0][IR_], 2, (S_IMGW>>1)+90, S_IMGH-40, iTS);
   	ScalableNumber((short) iTS->O_FZ_Feature[0][VE_], 2, (S_IMGW>>1)-40,S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][CL_], 2, (S_IMGW>>1)-30, S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][SD_], 2, (S_IMGW>>1)-20, S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][BB_], 2, (S_IMGW>>1)-10, S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][HE_], 2, (S_IMGW>>1), S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][IR_], 2, (S_IMGW>>1)+10, S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][DS] , 2, (S_IMGW>>1)+20, S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][BSD], 2, (S_IMGW>>1)+30, S_IMGH-40+15, iTS);
	ScalableNumber((short) iTS->O_FZ_Feature[0][PV] , 2, (S_IMGW>>1)+40, S_IMGH-40+15, iTS);
#endif

	return 1;

}

#ifdef DRAW_VEHICLE_POSITION_ON_OFF
void V_DrawVehiclePosition(CARINFO_ *CarInfo, short bottom_bound, ITS *iTS)
{
	unsigned short height_of_bar = 6;
	unsigned short buttom_bound_limit = S_IMGH - L_IB_BB_SearchLane - height_of_bar;
	unsigned int left_bound = 0;
	unsigned int right_bound = 0;

	bottom_bound = S_IMGH - bottom_bound;

	if(bottom_bound >= buttom_bound_limit)
		bottom_bound = buttom_bound_limit;

	left_bound = ((iTS->V_last_vehicle_left_bound * 7) + CarInfo->Position.LB) >> 3;
	right_bound = ((iTS->V_last_vehicle_right_bound * 7) + CarInfo->Position.RB) >> 3;

	iTS->V_last_vehicle_left_bound = left_bound;
	iTS->V_last_vehicle_right_bound = right_bound;

	if(iTS->W_Obstacle == SafeDistance)
	{
		OSD_Color_Setup(OCN_GREEN, iTS);
	}
	else if(iTS->W_Obstacle == WarningDistance)
	{
		OSD_Color_Setup(OCN_YELLOW, iTS);
	}
	else if(iTS->W_Obstacle == DangerousDistance)
	{
		OSD_Color_Setup(OCN_RED, iTS);
	}

	DrawBar(bottom_bound, left_bound, height_of_bar, right_bound - left_bound, iTS);
}
#endif

//#define SHOW_LIMITE_RIDE_MARK_OBJECT
short O_FindObstacle(ITS *iTS)
{
	short HR = 0;
	short TopBound = 0;
	short BottomBound = 0;
	short left_boundary = 0;
	short right_boundary = 0;
	
	short Tracking100W = 0;

	short limited_left = 0;
	short limited_right = 0;
	short limited_center = 0;
    short limited_do_or_not = 0;
			
	
	O_FuzzyUpdatePerFrame(iTS);    	//執行程式前 必更新FuzzyArray裡的記錄值
	P_ResetShadowSpeedFlag(iTS);	//執行程式前 必更新加速演算法記錄值

	BottomBound = LimitSearchingBoundary(O_IB_BB_SearchVehicle, iTS);

	if(iTS->CAR->StableCtr==0)    //Search Mode
	{	
		V_CleanCarInfo(&iTS->CAR->CarInfo);
		iTS->CAR->UpExtCtr=0;
		iTS->CAR->DownExtCtr=0;

		iTS->V_tail_edge_found_row = 0;

		iTS->CAR->CarInfo.Position.LB = iTS->O_LaneBound[S_IMGCW].Frt;
		iTS->CAR->CarInfo.Position.RB = iTS->O_LaneBound[S_IMGCW].Scd;
  
		TopBound =  LimitSearchingBoundary(iTS->V_serching_boundary, iTS);
		BottomBound = LimitSearchingBoundary(O_SetPossiblePosition(BottomBound, TopBound, 0, iTS), iTS);

		if(TopBound > BottomBound && O_Search_RowByRow(BottomBound, TopBound, iTS))
		{
			V_UpdateCarInfoFromFZCar(&iTS->CAR->CarInfo,iTS);
			iTS->CAR->StableCtr=1;
		}
		else if(iTS->first_search_row > iTS->V_distance_number[0] && iTS->V_tail_edge_found_row != 0)
		{
			iTS->CAR->StableCtr = 1;
			iTS->CAR->CarInfo.Position.BB = iTS->V_tail_edge_found_row;
			iTS->CAR->CarInfo.Position.LB = iTS->O_LaneBound[iTS->V_tail_edge_found_row].Frt;
			iTS->CAR->CarInfo.Position.RB = iTS->O_LaneBound[iTS->V_tail_edge_found_row].Scd;
			iTS->CAR->CarInfo.Position.BW = iTS->CAR->CarInfo.Position.RB - iTS->CAR->CarInfo.Position.LB;
			iTS->CAR->CarInfo.Position.BH = (short)(iTS->CAR->CarInfo.Position.BW * 0.75);
			iTS->CAR->CarInfo.Position.TB = iTS->CAR->CarInfo.Position.BB + iTS->CAR->CarInfo.Position.BH;
			iTS->CAR->CarInfo.Ctype = PatchMethod_01;
		}
		else if(iTS->day_or_night_flag == IS_NIGHTTIME && iTS->first_search_row != 0 && iTS->first_search_row < iTS->V_serching_boundary &&
			iTS->first_search_row > iTS->V_distance_number[0] && F_V_ProjectionFeatrueExtraction(iTS->O_LaneBound[iTS->first_search_row].Frt, iTS->O_LaneBound[iTS->first_search_row].Scd, iTS))
		{
			iTS->CAR->StableCtr = 1;
			iTS->CAR->CarInfo.Position.BB = iTS->first_search_row;
			iTS->CAR->CarInfo.Position.LB = iTS->O_LaneBound[iTS->first_search_row].Frt;
			iTS->CAR->CarInfo.Position.RB = iTS->O_LaneBound[iTS->first_search_row].Scd;
			iTS->CAR->CarInfo.Position.BW = iTS->CAR->CarInfo.Position.RB - iTS->CAR->CarInfo.Position.LB;
			iTS->CAR->CarInfo.Position.BH = (short)(iTS->CAR->CarInfo.Position.BW * 0.75);
			iTS->CAR->CarInfo.Position.TB = iTS->CAR->CarInfo.Position.BB + iTS->CAR->CarInfo.Position.BH;
			iTS->CAR->CarInfo.Ctype = PatchMethod_02;
		}
		else
			iTS->CAR->StableCtr=0;

		if(iTS->CAR->StableCtr != 0)
		{
			iTS->V_LAST_BB_use_flag = 0;
			iTS->V_last_vehicle_left_bound = iTS->CAR->CarInfo.Position.LB;
			iTS->V_last_vehicle_right_bound = iTS->CAR->CarInfo.Position.RB;
			iTS->V_last_vehicle_distance_number_position = (iTS->CAR->CarInfo.Position.LB + iTS->CAR->CarInfo.Position.RB) >> 1;
		}
	}
	else	//Tracking Mode
	{
		iTS->V_tail_edge_found_row = 0;
			
		Tracking100W = O_DWtoDI(150, iTS->CAR->CarInfo.Position.BB, iTS);
		BottomBound = LimitSearchingBoundary(iTS->CAR->CarInfo.Position.BB - Tracking100W, iTS);
		TopBound =  LimitSearchingBoundary(iTS->V_serching_boundary, iTS);
		BottomBound = O_SetPossiblePosition(BottomBound, TopBound, 1, iTS);

		if(O_Tracking_RowByRow(BottomBound, Tracking100W, iTS))
		{
			V_UpdateCarInfoFromFZCar(&iTS->CAR->CarInfo,iTS);

			if(iTS->CAR->CarInfo.Ctype == Night_CL)
				iTS->CAR->StableCtr+=4;
			else if(iTS->CAR->CarInfo.Ctype == Night_HE)
				iTS->CAR->StableCtr+=4;
			else if(iTS->CAR->CarInfo.Ctype == Day)
				iTS->CAR->StableCtr+=2;
			else if(iTS->CAR->CarInfo.Ctype == CarCorner)
				iTS->CAR->StableCtr+=2;
			else
				iTS->CAR->StableCtr++;
		}
		else if(iTS->first_search_row > iTS->V_distance_number[0] && iTS->V_tail_edge_found_row != 0)
		{
			iTS->CAR->StableCtr ++;
			iTS->CAR->CarInfo.Position.BB = iTS->V_tail_edge_found_row;

			left_boundary = iTS->O_LaneBound[iTS->V_tail_edge_found_row].Frt;
			right_boundary = iTS->O_LaneBound[iTS->V_tail_edge_found_row].Scd;

			if(F_V_FindBoundaryUsedExistedVerticalEdgeProjection(LimitW(left_boundary - 20), LimitW(right_boundary + 20), iTS) == 0)
			{
				iTS->CAR->CarInfo.Position.LB = left_boundary;
				iTS->CAR->CarInfo.Position.RB = right_boundary;
			}
			iTS->CAR->CarInfo.Position.BW = iTS->CAR->CarInfo.Position.RB  - iTS->CAR->CarInfo.Position.LB;
			iTS->CAR->CarInfo.Position.BH = (short)(iTS->CAR->CarInfo.Position.BW * 0.75);
			iTS->CAR->CarInfo.Position.TB = iTS->CAR->CarInfo.Position.BB + iTS->CAR->CarInfo.Position.BH;
			iTS->CAR->CarInfo.Ctype = PatchMethod_01;
		}
		else if(iTS->day_or_night_flag == IS_NIGHTTIME && iTS->first_search_row != 0 && iTS->first_search_row < iTS->V_serching_boundary &&
			iTS->first_search_row > iTS->V_distance_number[0] && F_V_ProjectionFeatrueExtraction(iTS->O_LaneBound[iTS->first_search_row].Frt, iTS->O_LaneBound[iTS->first_search_row].Scd, iTS))
		{
			iTS->CAR->StableCtr++;
			iTS->CAR->CarInfo.Position.BB = iTS->first_search_row;

			left_boundary = iTS->O_LaneBound[iTS->first_search_row].Frt;
			right_boundary = iTS->O_LaneBound[iTS->first_search_row].Scd;
			
			if(F_V_FindBoundaryUsedExistedVerticalEdgeProjection(LimitW(left_boundary - 20), LimitW(right_boundary + 20), iTS) == 0)
			{
				iTS->CAR->CarInfo.Position.LB = left_boundary;
				iTS->CAR->CarInfo.Position.RB = right_boundary;
			}
			iTS->CAR->CarInfo.Position.BW = iTS->CAR->CarInfo.Position.RB  - iTS->CAR->CarInfo.Position.LB;
			iTS->CAR->CarInfo.Position.BH = (short)(iTS->CAR->CarInfo.Position.BW * 0.75);
			iTS->CAR->CarInfo.Position.TB = iTS->CAR->CarInfo.Position.BB + iTS->CAR->CarInfo.Position.BH;
			iTS->CAR->CarInfo.Ctype = PatchMethod_02;
		}
		else
			iTS->CAR->StableCtr--;
	}

	iTS->CAR->CarInfo.Position.BB = LimitSearchingBoundary(iTS->CAR->CarInfo.Position.BB, iTS);

	//車道線上誤偵測
	limited_left = iTS->CAR->CarInfo.Position.LB + (iTS->CAR->CarInfo.Position.BW >> 2);
	limited_right = iTS->CAR->CarInfo.Position.RB - (iTS->CAR->CarInfo.Position.BW >> 2);
	limited_center = (iTS->CAR->CarInfo.Position.RB + iTS->CAR->CarInfo.Position.LB) >> 1;


	if((iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Frt > limited_left && iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Frt < limited_right) ||
	(iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Scd > limited_left && iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Scd < limited_right))
	{
		limited_do_or_not = 1;
	}

	if(iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Scd > iTS->CAR->CarInfo.Position.LB && iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Scd < limited_center)
	{
		limited_do_or_not = 1;

	}

	if(iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Frt < iTS->CAR->CarInfo.Position.RB && iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Frt > limited_center)
	{
		limited_do_or_not = 1;
	}
	
/*	if(iTS->L_StbCtr == 15 && iTS->CAR->RealDistance > 1500 && limited_do_or_not && 
		iTS->CAR->StableCtr < iTS->V_draw_vehicle_position)
	{

#ifdef SHOW_LIMITE_RIDE_MARK_OBJECT
		OSD_Color_Setup(OCN_YELLOW, iTS);
		DrawRect_Has_UV(150, S_IMGCW, 20, iTS);
#endif
		iTS->CAR->StableCtr = 0;
		return 0;
	}*/

/*	if((iTS->CAR->CarInfo.Position.RB - iTS->CAR->CarInfo.Position.LB) < 
		(iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Scd - iTS->L_LaneMBound[iTS->CAR->CarInfo.Position.BB].Frt) >> 2 &&
		iTS->CAR->StableCtr < iTS->V_draw_vehicle_position)
	{
		iTS->CAR->StableCtr = 0;
	}*/

#ifdef VEHICLE_VERIFY_SYMMETRY_PROCESS_ON_OFF
	if(iTS->CAR->StableCtr != 0)
	{
		if(F_V_VehicleVerifySymmetryProcess(iTS) == 0)
		{
			if(iTS->CAR->StableCtr < iTS->V_draw_vehicle_position)
			{
				iTS->CAR->StableCtr = 0;
				return 0;
			}
			else
			{
				iTS->CAR->StableCtr--;
			}
		}
	}
#endif

#ifdef O_SHOW_HORIZONTAL_PROJECTION_ON_OFF
	O_ShowHEHP(iTS->Showimage,iTS);    // for DSP Debug
#endif 

#ifdef O_SHOW_VERTICAL_PROJECTION_ON_OFF
	O_ShowVEVP(iTS->Showimage,iTS);    // for DSP Debug
#endif

#ifdef O_DRAW_LAND_BOUND_ON_OFF	         
	memset(&iTS->Showimage[SinkDataIndexStart(TopBound) + iTS->F_W + iTS->O_LaneBound[TopBound].Frt], 255, (iTS->O_LaneBound[TopBound].Scd - iTS->O_LaneBound[TopBound].Frt));
	memset(&iTS->Showimage[SinkDataIndexStart(BottomBound) + iTS->F_W + iTS->O_LaneBound[BottomBound].Frt], 255, (iTS->O_LaneBound[BottomBound].Scd - iTS->O_LaneBound[BottomBound].Frt));
#endif

	//Bottom Boundary Smothing
	if(iTS->V_LAST_BB_use_flag)
	{
		iTS->CAR->CarInfo.Position.BB = (short) ((iTS->CAR->CarInfo.Position.BB + iTS->V_LAST_BB * 3) >> 2);
	}
	else
	{
		iTS->V_LAST_BB_use_flag = 1;
	}
	iTS->V_LAST_BB = iTS->CAR->CarInfo.Position.BB;

	iTS->CAR->StableCtr=LimitCount(iTS->CAR->StableCtr,O_FC_MaxVihecleStableNumber);

	DistanceSmoothing(iTS->CAR,iTS);

	HR = ((iTS->V_last_vehicle_distance_number_position * 7) + ((iTS->CAR->CarInfo.Position.LB + iTS->CAR->CarInfo.Position.RB) >> 1)) >> 3;
	iTS->V_last_vehicle_distance_number_position = HR;

	if(iTS->CAR->CarInfo.Ctype != None && iTS->CAR->StableCtr > iTS->V_draw_vehicle_position)
	{
		if(iTS->CAR->RealDistance <= O_MAX_DISTANCE)
		{
			W_SetObstacleWarring(iTS);
#ifdef DRAW_VEHICLE_POSITION_ON_OFF		
			V_DrawVehiclePosition(&iTS->CAR->CarInfo, iTS->V_LAST_BB,iTS);    //µe¥X¨®½ø©³³¡
#endif

			DrawDistance(iTS->CAR->RealDistance,(S_IMGH - iTS->V_LAST_BB - 40),HR,iTS);
		}
	}

	return 1;
}

//#define DRAW_DETECTION_AREA
//#define DRAW_DAY_OR_NIGHT_BLOCK
void F_V_DetectionDayOrNight(short bottom_bound, short top_bound, short left_bound, short right_bound, ITS * iTS)
{
	short row = 0;
	short col = 0;
	unsigned char *source;
	unsigned int gray_level_average = 0;
	short pixel_count = 0;

	for(row = bottom_bound; row <= top_bound; row++)
	{
		source = &iTS->YImg[iTS->row_width_culmulative[S_IMGH - 1 - (row - 1)]];

		for(col = left_bound; col < right_bound; col++)
		{
			gray_level_average += source[col];
			pixel_count++;
		}
	}

	gray_level_average = gray_level_average / pixel_count;
	
	if(iTS->CAR->StableCtr == 0)
	{
		if(gray_level_average > DAY_OR_NIGHT_THRESHOLD)
		{
			iTS->day_or_night_count = LimitCount(++iTS->day_or_night_count, DAY_OR_NIGHT_FRAME_COUNTER_SIZE);
		}
		else
		{
			iTS->day_or_night_count = LimitCount(--iTS->day_or_night_count, DAY_OR_NIGHT_FRAME_COUNTER_SIZE);
		}
	}


	if(iTS->day_or_night_count >= DAY_OR_NIGHT_COUNTER_THRESHOLD)
	{

#ifdef DRAW_DAY_OR_NIGHT_BLOCK
		OSD_Color_Setup(OCN_BLACK, iTS); 
		DrawRect_Has_UV(6, 16, 20, iTS);
		OSD_Color_Setup(OCN_WHITE, iTS);
		DrawRect_Has_UV(8, 18, 16, iTS);
#endif
 
		iTS->day_or_night_flag = (char) IS_DAYTIME;
	}
	else
	{	

#ifdef DRAW_DAY_OR_NIGHT_BLOCK
		OSD_Color_Setup(OCN_WHITE, iTS); 
		DrawRect_Has_UV(6, 16, 20, iTS);
		OSD_Color_Setup(OCN_BLACK, iTS);
		DrawRect_Has_UV(8, 18, 16, iTS);
#endif 
		iTS->day_or_night_flag = (char) IS_NIGHTTIME;
	}

#ifdef DRAW_DETECTION_AREA
	OSD_Color_Setup(OCN_PURPLE, iTS); 
	ScalableNumber((short) gray_level_average, 2, right_bound + 10, (S_IMGH - top_bound), iTS);

	OSD_Color_Setup(OCN_RED, iTS); 
	ScalableNumber((short) DAY_OR_NIGHT_THRESHOLD, 2, right_bound + 10, (S_IMGH - top_bound) + 13, iTS);

	OSD_Color_Setup(OCN_GRAY, iTS);
	DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);
#endif

}


void O_FindHorizontalLine(ITS *iTS)
{
    O_CreateMarkInfo(iTS);
    //iTS->O_MarkLightTH = 150;

//iTS->Stop_Line.mode = SEARCH;


    if(iTS->Stop_Line.mode == SEARCH)
        O_StopLineSearch(L_IB_BB_SearchLane, L_IB_TB_TrackingLane, S_IMGLB + 1, S_IMGRB - 1, iTS);
    else if(iTS->Stop_Line.mode == TRACE)
    {
        if(O_StopLineTracking(iTS))
        {
            iTS->Stop_Line.stable_counter++;
            if(iTS->Stop_Line.stable_counter > 15)
                iTS->Stop_Line.stable_counter = 15;
        }
        else
        {
            iTS->Stop_Line.stable_counter--;
            if(iTS->Stop_Line.stable_counter == 0)
            {
                iTS->Stop_Line.stable_counter = 0;
                iTS->Stop_Line.mode = SEARCH;
            }
        }
    }


}

short O_StopLineSearch(short bottom_bound, short top_bound, short left_bound, short right_bound, ITS *iTS)
{
    short col,row_;

    unsigned char *CenterGray,*UpGray,*DnGray;
//    unsigned char *CurrentEdge,*DownEdge;

    short top_edge_row = 0;
    short bot_edge_row = 0;
   short edge_center_row = 0;

    short min_mark_width = 0;


    short default_mark_height = 0;
    short min_mark_height = 0;
    short max_mark_height = 0;

    short continue_pixels = 0;
    short not_continue_pixels = 0;



//    OSD_Color_Setup(OCN_YELLOW, iTS);
//    DrawColorLine(bottom_bound, iTS->O_LaneMBound[bottom_bound].Frt - 20, iTS->O_LaneMBound[bottom_bound].Scd + 20, iTS);
//    DrawColorLine(top_bound, iTS->O_LaneMBound[top_bound - 1 ].Frt - 20, iTS->O_LaneMBound[top_bound - 1].Scd + 20, iTS);

//    col=0;
//    for(row_= bottom_bound; row_< top_bound; row_++)
//    {
//        min_mark_height = O_GetRowDistanceBetweenRowAndRow(O_Mark_Min_H, row_, iTS);
//        max_mark_height = O_GetRowDistanceBetweenRowAndRow(O_Mark_Max_H, row_, iTS);
//        OSD_Color_Setup(OCN_PURPLE, iTS);
//        DrawRectangle(row_, row_ + max_mark_height, col, col+1, iTS);
//        OSD_Color_Setup(OCN_ORANGE, iTS);
//        DrawRectangle(row_, row_ + min_mark_height, col+2, col+3, iTS);

//        col +=8;
//    }





//    for(row_= bottom_bound; row_< top_bound; row_++)
//    {
//        OSD_Color_Setup(OCN_YELLOW, iTS);
//        DrawColorLine(row_, iTS->O_LaneMBound[row_].Frt - 20, iTS->O_LaneMBound[row_].Frt - 20 + 1, iTS);
//        DrawColorLine(row_, iTS->O_LaneMBound[row_].Scd + 20, iTS->O_LaneMBound[row_].Scd + 20 +1, iTS);


//        //for(col = left_bound;col < right_bound; col++)
//        for(col = iTS->O_LaneMBound[row_].Frt - 20 ;col < iTS->O_LaneMBound[row_].Scd + 20; col++)
//        {

//            CenterGray = &iTS->YImg[GetImageDataIndex(row_)];
//            if(CenterGray[col] > iTS->O_MarkLightTH)
//            {
//                OSD_Color_Setup(OCN_WHITE, iTS);
//                DrawColorLine(row_, col, col + 1, iTS);
//            }
//            else
//            {
//                OSD_Color_Setup(OCN_BLACK, iTS);
//                DrawColorLine(row_, col, col + 1, iTS);
//            }
//        }
//    }




    for(row_= bottom_bound; row_< top_bound; row_++)
    {
        continue_pixels = 0;
        not_continue_pixels = 0;

        min_mark_height = DWtoDI(O_Mark_Min_H, (EV_ROAD_SLOPE - (row_ - iTS->F_H_C)));
        max_mark_height = DWtoDI(O_Mark_Max_H, (EV_ROAD_SLOPE - (row_ - iTS->F_H_C)));
        default_mark_height = DWtoDI(O_Mark_Def_H, (EV_ROAD_SLOPE - (row_ - iTS->F_H_C)));

        if(max_mark_height < 3)
            max_mark_height = 3;

        CenterGray = &iTS->YImg[GetImageDataIndex(row_)];
        UpGray     = &iTS->YImg[GetImageDataIndex(row_ - (default_mark_height>>1))];
        DnGray     = &iTS->YImg[GetImageDataIndex(row_ + (default_mark_height>>1))];


//        OSD_Color_Setup(OCN_YELLOW, iTS);
//        DrawColorLine(row_, iTS->O_LaneMBound[row_].Frt - 20, iTS->O_LaneMBound[row_].Frt - 20 + 1, iTS);
//        DrawColorLine(row_, iTS->O_LaneMBound[row_].Scd + 20, iTS->O_LaneMBound[row_].Scd + 20 +1, iTS);


        //for(col = left_bound;col < right_bound; col++)
        for(col = iTS->O_LaneMBound[row_].Frt - 20 ;col < iTS->O_LaneMBound[row_].Scd + 20; col++)
        {

            if(CenterGray[col] > iTS->O_MarkLightTH && DnGray[col] < iTS->O_MarkLightTH && UpGray[col] < iTS->O_MarkLightTH)
            {
                top_edge_row = O_FindHorizontalMarkEdge(col, (row_ + max_mark_height),  row_, iTS);
                bot_edge_row = O_FindHorizontalMarkEdge(col, (row_ - max_mark_height),  row_, iTS);
                edge_center_row = ((top_edge_row - bot_edge_row) / 2) + 1;
                edge_center_row = edge_center_row + bot_edge_row;

               // min_mark_height = O_GetRowDistanceBetweenRowAndRow(O_Mark_Min_H, bot_edge_row, iTS);

//                OSD_Color_Setup(OCN_RED, iTS);
//                DrawRectangle(bot_edge_row, top_edge_row, col, col+1, iTS);
//                OSD_Color_Setup(OCN_YELLOW, iTS);
//                DrawColorLine(edge_center_row, col, col + 1, iTS);



                if(top_edge_row !=0 && bot_edge_row != 0 && (top_edge_row - bot_edge_row) > min_mark_height)
                {
//                    OSD_Color_Setup(OCN_RED, iTS);
//                    DrawRectangle(bot_edge_row, top_edge_row, col, col+1, iTS);
//                    OSD_Color_Setup(OCN_YELLOW, iTS);
//                    DrawColorLine(edge_center_row, col, col + 1, iTS);

                    if(continue_pixels == 0 /*&& iTS->Hor_mark[iTS->Hor_mark_counter].start_flag == 0*/)
                    {
                        iTS->Stop_Line.start_row = edge_center_row;
                        iTS->Stop_Line.start_col = col;
                        iTS->Stop_Line.start_flag = 1;

                        iTS->Stop_Line.BB = bot_edge_row;
                        iTS->Stop_Line.TB = top_edge_row;

                    }

                    if(abs(edge_center_row - iTS->Stop_Line.start_row) < max_mark_height)
                    {

//                        if(continue_pixels == 0)
//                        {
//                            CurrentEdge = &iTS->O_InfoPlane[GetImageDataIndex(bot_edge_row )];
//                            DownEdge    = &iTS->O_InfoPlane[GetImageDataIndex(bot_edge_row + 2)];

//                            if(((CurrentEdge[col    ] & HEINFO) == HEINFO && (CurrentEdge[col    ] & VEINFO) != VEINFO) &&
//                               ((CurrentEdge[col + 2] & HEINFO) == HEINFO && (CurrentEdge[col + 2] & VEINFO) != VEINFO) &&
//                               (((DownEdge   [col    ] & VEINFO) == VEINFO) ||((DownEdge   [col -1 ] & VEINFO) == VEINFO )))
//                            {
//                                if(top_edge_row > iTS->Stop_Line.TB)
//                                    iTS->Stop_Line.TB = top_edge_row;
//                                if(bot_edge_row < iTS->Stop_Line.BB)
//                                    iTS->Stop_Line.BB = bot_edge_row;

//                                continue_pixels++;
//                                not_continue_pixels = 0;

//                            }
//                            else
//                                not_continue_pixels++;
//                        }
//                        else
                        {
                            if(top_edge_row > iTS->Stop_Line.TB)
                                iTS->Stop_Line.TB = top_edge_row;
                            if(bot_edge_row < iTS->Stop_Line.BB)
                                iTS->Stop_Line.BB = bot_edge_row;

                            continue_pixels++;
                            not_continue_pixels = 0;
                        }

                    }
                    else
                        not_continue_pixels++;
                }
                else
                    not_continue_pixels++;

            }
            else
                not_continue_pixels++;


            //if(continue_pixels != 0 && not_continue_pixels > O_Not_Continue_TH)
            if((continue_pixels != 0 && not_continue_pixels > O_Not_Continue_TH) || (continue_pixels != 0 && col ==  iTS->O_LaneMBound[row_].Scd + 20 - 1))
            {

                iTS->Stop_Line.LB = iTS->Stop_Line.start_col;
                iTS->Stop_Line.RB = col - not_continue_pixels;
                iTS->Stop_Line.BW = iTS->Stop_Line.RB - iTS->Stop_Line.LB;
                iTS->Stop_Line.BH = iTS->Stop_Line.TB - iTS->Stop_Line.BB;

                min_mark_width = DWtoDI(O_Min_Mark_W, (EV_ROAD_SLOPE - (iTS->Stop_Line.BB - iTS->F_H_C)));


                if(iTS->Stop_Line.BW > min_mark_width /*&& iTS->Hor_mark[iTS->Hor_mark_counter].BH < max_mark_height*2*/)
                {
                    iTS->Stop_Line.mode = TRACE;
                    iTS->Stop_Line.stable_counter=1;

//                    OSD_Color_Setup(OCN_BLUE, iTS);
//                    DrawRectangle(iTS->Stop_Line.BB, iTS->Stop_Line.TB, iTS->Stop_Line.LB, iTS->Stop_Line.RB, iTS);
                    return 1;
                }
                else
                {
                    iTS->Stop_Line.start_flag = 0;
                }

                continue_pixels = 0;
            }

        }
    }

    iTS->Stop_Line.mode = SEARCH;
    iTS->Stop_Line.stable_counter = 0;
    return 0;


}

short O_StopLineTracking(ITS *iTS)
{
    short col,row_;

    unsigned char *CenterGray,*UpGray,*DnGray;

    short top_edge_row = 0;
    short bot_edge_row = 0;
    short edge_center_row = 0;
    short last_edge_center_row = 0;

    short min_mark_width = 0;

    short min_mark_height = 0;
    short max_mark_height = 0;
    short default_mark_height = 0;

    short continue_pixels = 0;
    short not_continue_pixels = 0;



    short bottom_bound = iTS->Stop_Line.BB - (iTS->Stop_Line.BH );
    short top_bound    = iTS->Stop_Line.TB + (iTS->Stop_Line.BH );
    short left_bound   = iTS->Stop_Line.LB - (iTS->Stop_Line.BW >> 2);
    short right_bound  = iTS->Stop_Line.RB + (iTS->Stop_Line.BW >> 2);

    short last_TB       = iTS->Stop_Line.BB;
    short last_BB       = iTS->Stop_Line.TB;
    short last_LB       = iTS->Stop_Line.LB;
    short last_RB       = iTS->Stop_Line.RB;
    short last_distance = iTS->Stop_Line.distance;

    if(bottom_bound < L_IB_BB_SearchLane)
        bottom_bound = L_IB_BB_SearchLane;
    if(top_bound > L_IB_TB_TrackingLane)
        top_bound = L_IB_TB_TrackingLane;
    if(left_bound < (iTS->O_LaneMBound[bottom_bound].Frt - 20))
        left_bound = (iTS->O_LaneMBound[bottom_bound].Frt - 20);
    if(right_bound > (iTS->O_LaneMBound[bottom_bound].Scd + 20))
        right_bound = (iTS->O_LaneMBound[bottom_bound].Scd + 20);




    //Draw ROI
//    OSD_Color_Setup(OCN_YELLOW, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);



    for(row_= bottom_bound; row_< top_bound; row_++)
    {
        continue_pixels = 0;
        not_continue_pixels = 0;

        min_mark_height = DWtoDI(O_Mark_Min_H, (EV_ROAD_SLOPE - (row_ - iTS->F_H_C)));
        max_mark_height = DWtoDI(O_Mark_Max_H, (EV_ROAD_SLOPE - (row_ - iTS->F_H_C)));
        default_mark_height = DWtoDI(O_Mark_Def_H, (EV_ROAD_SLOPE - (row_ - iTS->F_H_C)));
        if(max_mark_height < 3)
            max_mark_height = 3;

        CenterGray = &iTS->YImg[GetImageDataIndex(row_)];
        UpGray     = &iTS->YImg[GetImageDataIndex(row_ + (default_mark_height>>1))];
        DnGray     = &iTS->YImg[GetImageDataIndex(row_ - (default_mark_height>>1))];

        for(col = left_bound;col < right_bound; col++)
        {

            if(CenterGray[col] > iTS->O_MarkLightTH && DnGray[col] < iTS->O_MarkLightTH && UpGray[col] < iTS->O_MarkLightTH)
            {
                top_edge_row = O_FindHorizontalMarkEdge(col, (row_ + max_mark_height),  row_, iTS);
                bot_edge_row = O_FindHorizontalMarkEdge(col, (row_ - max_mark_height),  row_, iTS);
                edge_center_row = ((top_edge_row - bot_edge_row) / 2) + 1;
                edge_center_row = edge_center_row + bot_edge_row;

                if(top_edge_row !=0 && bot_edge_row != 0 && (top_edge_row - bot_edge_row) > min_mark_height)
                {
                     //Draw find Mark
//                    OSD_Color_Setup(OCN_RED, iTS);
//                    DrawRectangle(bot_edge_row, top_edge_row, col, col+1, iTS);
//                    OSD_Color_Setup(OCN_YELLOW, iTS);
//                    DrawColorLine(edge_center_row, col, col + 1, iTS);

                    if(continue_pixels == 0)
                    {
                        iTS->Stop_Line.start_row = row_;
                        iTS->Stop_Line.start_col = col;

                        iTS->Stop_Line.BB = bot_edge_row;
                        iTS->Stop_Line.TB = top_edge_row;
                        last_edge_center_row = edge_center_row;

                    }

                   // if(abs(edge_center_row - iTS->Stop_Line.start_row) < max_mark_height)
                    if(abs(edge_center_row - last_edge_center_row) < max_mark_height)
                    {
                        if(top_edge_row > iTS->Stop_Line.TB)
                            iTS->Stop_Line.TB = top_edge_row;
                        if(bot_edge_row < iTS->Stop_Line.BB)
                            iTS->Stop_Line.BB = bot_edge_row;

                        continue_pixels++;
                        not_continue_pixels = 0;
                    }
                   // else
                    //    not_continue_pixels++;
                }
                else
                    not_continue_pixels++;

            }
            else
                not_continue_pixels++;


            if((continue_pixels != 0 && not_continue_pixels > O_Not_Continue_TH) || (continue_pixels != 0 && col == right_bound - 1))
            {

                iTS->Stop_Line.LB = iTS->Stop_Line.start_col;
                iTS->Stop_Line.RB = col - not_continue_pixels;
                iTS->Stop_Line.BW = iTS->Stop_Line.RB - iTS->Stop_Line.LB;
                iTS->Stop_Line.BH = iTS->Stop_Line.TB - iTS->Stop_Line.BB;

                min_mark_width = DWtoDI(O_Min_Mark_W, (EV_ROAD_SLOPE - (iTS->Stop_Line.BB - iTS->F_H_C)));


                if(iTS->Stop_Line.BW > min_mark_width /*&& iTS->Hor_mark[iTS->Hor_mark_counter].BH < max_mark_height*2*/)
                {
                    if(iTS->Stop_Line.stable_counter > 5)
                    {
                        iTS->Stop_Line.distance = O_GetDistance(iTS->Stop_Line.BB, iTS);
                        OSD_Color_Setup(OCN_RED, iTS);
                        // DrawRectangle(iTS->Stop_Line.BB, iTS->Stop_Line.TB, iTS->Stop_Line.LB, iTS->Stop_Line.RB, iTS);
                        DrawBar(S_IMGH - iTS->Stop_Line.TB, iTS->Stop_Line.LB, iTS->Stop_Line.BH, iTS->Stop_Line.BW, iTS);
                        OSD_Color_Setup(OCN_YELLOW, iTS);
                        ScalableNumber(iTS->Stop_Line.distance, 2, iTS->Stop_Line.LB, S_IMGH - iTS->Stop_Line.BB, iTS);
                        Draw_cm(0, iTS->Stop_Line.LB + 25, S_IMGH - iTS->Stop_Line.BB, iTS);
                    }

                    if(iTS->Stop_Line.LB > iTS->O_LaneMBound[row_].Scd || iTS->Stop_Line.RB < iTS->O_LaneMBound[row_].Frt)
                    {
                        iTS->Stop_Line.stable_counter = 0;
                        iTS->Stop_Line.mode = SEARCH;
                        return 0;
                    }
                    return 1;
                }

                continue_pixels = 0;
            }

        }
    }

    iTS->Stop_Line.TB = last_TB;
    iTS->Stop_Line.BB = last_BB;
    iTS->Stop_Line.LB = last_LB;
    iTS->Stop_Line.RB = last_RB;
    iTS->Stop_Line.BW = iTS->Stop_Line.RB - iTS->Stop_Line.LB;
    iTS->Stop_Line.BH = iTS->Stop_Line.TB - iTS->Stop_Line.BB;
    iTS->Stop_Line.distance = last_distance;

    if(iTS->Stop_Line.stable_counter > 5)
    {
        OSD_Color_Setup(OCN_RED, iTS);
        // DrawRectangle(iTS->Stop_Line.BB, iTS->Stop_Line.TB, iTS->Stop_Line.LB, iTS->Stop_Line.RB, iTS);
        DrawBar(S_IMGH - iTS->Stop_Line.TB, iTS->Stop_Line.LB, iTS->Stop_Line.BH, iTS->Stop_Line.BW, iTS);
        OSD_Color_Setup(OCN_YELLOW, iTS);
        ScalableNumber(iTS->Stop_Line.distance, 2, iTS->Stop_Line.LB, S_IMGH - iTS->Stop_Line.BB, iTS);
        Draw_cm(0, iTS->Stop_Line.LB + 25, S_IMGH - iTS->Stop_Line.BB, iTS);
    }


    return 0;

}

short O_FindHorizontalMarkEdge(short current_col,  short from_outside, short to_center, ITS *iTS)
{
    unsigned char *SearchRow;
    short index = 0;

    if(from_outside > to_center)
    {
        for ( index = from_outside; index >= to_center; index--)
        {
            SearchRow = &iTS->O_InfoPlane[GetImageDataIndex(index)];
           // SearchRow = &iTS->YImg[GetImageDataIndex(index)];
            if((SearchRow[current_col] & HEINFO) == HEINFO && (SearchRow[current_col] & VEINFO) != VEINFO)
            //if(SearchRow[current_col] > iTS->O_MarkLightTH)
            {
                return index;
            }
        }
    }
    else
    {
        for ( index = from_outside; index <= to_center; index++)
        {
            SearchRow = &iTS->O_InfoPlane[GetImageDataIndex(index)];
            //SearchRow = &iTS->YImg[GetImageDataIndex(index)];
            if((SearchRow[current_col] & HEINFO) == HEINFO && (SearchRow[current_col] & VEINFO) != VEINFO)
            //if(SearchRow[current_col] > iTS->O_MarkLightTH)
            {
                return index;
            }
        }

    }
    return 0;//from_outside;
}


void O_PedestrianDetection(ITS *iTS)
{

//    iTS->adult.stable_counter = 0;
//    iTS->adult.mode = SEARCH;

    if(iTS->function_switch.adult_detection == 1)
    {
        if(iTS->people_detection_change_flag == 0 && iTS->adult.mode == SEARCH)
        {
            if(O_SearchAdultPedestrian(iTS))
            {
                iTS->adult.mode = TRACE;
                iTS->adult.stable_counter = 5;
            }
            else
            {
                iTS->adult.stable_counter = 0;
                iTS->adult.mode = SEARCH;
            }
        }
        else if(iTS->adult.mode == TRACE)
        {
            if(O_TrackingAdultPedestrian(iTS))
            {
                iTS->adult.mode = TRACE;
                if(iTS->adult.stable_counter < 15)
                    iTS->adult.stable_counter++;
            }
            else
            {
                iTS->adult.stable_counter--;
                if(iTS->adult.stable_counter <= 0)
                {
                    iTS->adult.stable_counter = 0;
                    iTS->adult.mode = SEARCH;
                }
            }

            if(iTS->adult.stable_counter > 5)
            {
                if(iTS->adult.direction == 1)
                    OSD_Color_Setup(OCN_ORANGE, iTS);
                else
                    OSD_Color_Setup(OCN_BLUE, iTS);
                DrawRectangle(iTS->adult.boundary.BB, iTS->adult.boundary.TB, iTS->adult.boundary.LB, iTS->adult.boundary.RB, iTS);
            }

        }
    }

//        iTS->child.stable_counter = 0;
//        iTS->child.mode = SEARCH;

    if(iTS->function_switch.child_detection == 1)
    {
        if(iTS->people_detection_change_flag == 1 && iTS->child.mode == SEARCH)
        {
            if(O_SearchChildPedestrian(iTS))
            {
                iTS->child.mode = TRACE;
                iTS->child.stable_counter = 5;
            }
            else
            {
                iTS->child.stable_counter = 0;
                iTS->child.mode = SEARCH;
            }
        }
        else if(iTS->child.mode == TRACE)
        {
            if(O_TrackingChildPedestrian(iTS))
            {
                iTS->child.mode = TRACE;
                if(iTS->child.stable_counter < 15)
                    iTS->child.stable_counter++;
            }
            else
            {
                iTS->child.stable_counter--;
                if(iTS->child.stable_counter <= 0)
                {
                    iTS->child.stable_counter = 0;
                    iTS->child.mode = SEARCH;
                }
            }

            if(iTS->child.stable_counter > 5)
            {
                OSD_Color_Setup(OCN_RED, iTS);
                DrawRectangle(iTS->child.boundary.BB, iTS->child.boundary.TB, iTS->child.boundary.LB, iTS->child.boundary.RB, iTS);
            }
        }
    }

    if(iTS->function_switch.adult_detection == 1 && iTS->function_switch.child_detection == 1)
    {
        if(iTS->people_detection_change_flag == 0)
            iTS->people_detection_change_flag = 1;
        else
            iTS->people_detection_change_flag = 0;
    }
    else if(iTS->function_switch.adult_detection == 1 && iTS->function_switch.child_detection == 0)
    {
        iTS->people_detection_change_flag = 0;
    }
    else if(iTS->function_switch.adult_detection == 0 && iTS->function_switch.child_detection == 1)
    {
        iTS->people_detection_change_flag = 1;
    }
    else
    {
        iTS->people_detection_change_flag = 1;
    }

}
int O_SearchAdultPedestrian(ITS *iTS)
{
#define FROM_EDGE
//#define FROM_HOG

    int row, col;

    unsigned short top_bound = S_IMGCH;
    unsigned short bottom_bound = L_IB_BB_SearchLane;
    unsigned short left_bound   = S_IMGCW;// S_IMGLB;
    unsigned short right_bound  = S_IMGRB;

    unsigned short new_bound[4] = {0};


    unsigned char *CrRow,*UpRow,*Up2Row;

    int width  = 0;
    int height = 0;


    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row<  top_bound; row++)
    {
        r=SinkDataIndexNextRow(r);

#ifdef FROM_HOG
        CrRow  = &iTS->Hog_InfoPlane[r];
        UpRow  = &iTS->Hog_InfoPlane[r-iTS->F_W];
        Up2Row = &iTS->Hog_InfoPlane[r-iTS->F_W-iTS->F_W];
#endif
#ifdef FROM_EDGE
        CrRow  = &iTS->O_InfoPlane[r];
        UpRow  = &iTS->O_InfoPlane[r-iTS->F_W];
        Up2Row = &iTS->O_InfoPlane[r-iTS->F_W-iTS->F_W];
#endif

        width  = DWtoDI(ADULT_DETECT_WIDTH, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));
        height = DWtoDI(ADULT_DETECT_HIGHT, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));

        if(width < 20)
            width = 20;
        if(width < 40)
            width = 40;

//        OSD_Color_Setup(OCN_YELLOW, iTS);
//        DrawColorLine(row, iTS->L_LaneMBound[row].Scd + 10, right_bound, iTS);

//        for(col = iTS->L_LaneMBound[row].Scd; col < right_bound + width; col++)
        for(col = left_bound; col < right_bound - width; col++)
        {

#ifdef FROM_HOG
            if(CrRow[col] != 0 && UpRow[col] != 0 && Up2Row[col] != 0)
#endif
#ifdef FROM_EDGE
            if((CrRow[col] & VEINFO) == VEINFO && (UpRow[col] & VEINFO) == VEINFO && (Up2Row[col] & VEINFO) == VEINFO)
#endif
            {
                if(O_FindAdultPeopleCandidate(row, col, width, height, &new_bound[0], iTS))
                {
                    iTS->adult.boundary.BB = new_bound[0];
                    iTS->adult.boundary.TB = new_bound[1];
                    iTS->adult.boundary.LB = new_bound[2];
                    iTS->adult.boundary.RB = new_bound[3];
                    iTS->adult.boundary.BH = height;
                    iTS->adult.boundary.BW = width;

//                    OSD_Color_Setup(OCN_YELLOW, iTS);
//                    DrawRectangle(iTS->adult.boundary.BB, iTS->adult.boundary.TB, iTS->adult.boundary.LB, iTS->adult.boundary.RB, iTS);

                    return 1;
                }
            }
        }
    }

    iTS->adult.stable_counter = 0;
    iTS->adult.mode = SEARCH;
    iTS->adult.distance = 0;
    iTS->adult.boundary.BB = 0;
    iTS->adult.boundary.TB = 0;
    iTS->adult.boundary.LB = 0;
    iTS->adult.boundary.RB = 0;
    iTS->adult.boundary.BH = 0;
    iTS->adult.boundary.BW = 0;

    return 0;
}

int O_TrackingAdultPedestrian(ITS *iTS)
{
#define FROM_EDGE
//#define FROM_HOG

    int row, col;

    unsigned short top_bound    = iTS->adult.boundary.TB;
    unsigned short bottom_bound = iTS->adult.boundary.BB - (iTS->adult.boundary.BH >> 2);
    unsigned short left_bound   = iTS->adult.boundary.LB - (iTS->adult.boundary.BW /3);
    unsigned short right_bound  = iTS->adult.boundary.RB + (iTS->adult.boundary.BW /3);

    if(top_bound > S_IMGCH )
        top_bound = (S_IMGCH);
    if(bottom_bound < (L_IB_BB_SearchLane + 1))
        bottom_bound = (L_IB_BB_SearchLane + 1);
    if(right_bound > S_IMGRB)
        right_bound = S_IMGRB;
    if(left_bound < S_IMGCW - 200)
        left_bound = S_IMGCW - 200;

    unsigned short new_bound[4] = {0};


     unsigned char *CrRow,*UpRow,*Up2Row;

     int width  = 0;
     int height = 0;


     int r = SinkDataIndexStart(bottom_bound);

     for(row= bottom_bound; row<  top_bound; row++)
     {
         r=SinkDataIndexNextRow(r);

 #ifdef FROM_HOG
         CrRow  = &iTS->Hog_InfoPlane[r];
         UpRow  = &iTS->Hog_InfoPlane[r-iTS->F_W];
         Up2Row = &iTS->Hog_InfoPlane[r-iTS->F_W-iTS->F_W];
 #endif
 #ifdef FROM_EDGE
         CrRow  = &iTS->O_InfoPlane[r];
         UpRow  = &iTS->O_InfoPlane[r-iTS->F_W];
         Up2Row = &iTS->O_InfoPlane[r-iTS->F_W-iTS->F_W];
 #endif

         width  = DWtoDI(ADULT_DETECT_WIDTH, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));
         height = DWtoDI(ADULT_DETECT_HIGHT, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));

         if(width < 20)
             width = 20;
         if(width < 40)
             width = 40;


         for(col = left_bound; col < right_bound - width; col++)
         {

 #ifdef FROM_HOG
             if(CrRow[col] != 0 && UpRow[col] != 0 && Up2Row[col] != 0)
 #endif
 #ifdef FROM_EDGE
             if((CrRow[col] & VEINFO) == VEINFO && (UpRow[col] & VEINFO) == VEINFO && (Up2Row[col] & VEINFO) == VEINFO)
 #endif
             {
 //                O_FindAdultPeopleCandidate(row - 3, (col), width, height, iTS);
                 if(O_FindAdultPeopleCandidate(row, col, width, height, &new_bound[0], iTS))
                 {
                     if(abs(height - iTS->adult.boundary.BH) < (iTS->adult.boundary.BH >>2))
                     {
                         iTS->adult.boundary.BB += new_bound[0];
                         iTS->adult.boundary.BB = iTS->adult.boundary.BB >> 1;
                         iTS->adult.boundary.TB += new_bound[1];
                         iTS->adult.boundary.TB = iTS->adult.boundary.TB >>1;
                         iTS->adult.boundary.LB += new_bound[2];
                         iTS->adult.boundary.LB = iTS->adult.boundary.LB >>1;
                         iTS->adult.boundary.RB += new_bound[3];
                         iTS->adult.boundary.RB = iTS->adult.boundary.RB >>1;
                         iTS->adult.boundary.BH += height;
                         iTS->adult.boundary.BH = iTS->adult.boundary.BH >> 1;
                         iTS->adult.boundary.BW += width;
                         iTS->adult.boundary.BW = iTS->adult.boundary.BW >> 1;



//                         OSD_Color_Setup(OCN_BLUE, iTS);
//                         DrawRectangle(iTS->adult.boundary.BB, iTS->adult.boundary.TB, iTS->adult.boundary.LB, iTS->adult.boundary.RB, iTS);
                         return 1;
                     }

                 }
             }
         }
     }


    return 0;
}


int O_AdultHumanDecision(int star_row, int star_col,int image_width, int image_height, ITS *iTS)
{
    int row, col;
    int index = 0;

    unsigned char *Gxy_result;
    unsigned char *Axy_result;

    int cell_width  = (int)(((double)image_width  / (double)ADULT_DETECT_WIDTH) + 0.5);
    int cell_height = (int)(((double)image_height / (double)ADULT_DETECT_HIGHT) + 0.5);
    int width  = cell_width  * ADULT_DETECT_WIDTH;
    int height = cell_height * ADULT_DETECT_HIGHT;

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = star_row ;
    unsigned short left_bound   = star_col;
    unsigned short right_bound  = 0;


    float *cell_direction_data;
    int cell_direction_data_counter = 0;

    float norm = 0;
    float prediction = 0;
    float direction_prediction = 0;


    top_bound = bottom_bound + height;
    right_bound = left_bound + width;

    if(top_bound > (S_IMGH - 20))
        return 0;
    if(right_bound > S_IMGRB)
         return 0;



    cell_direction_data = (float *) calloc( (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT), sizeof(float));


//    OSD_Color_Setup(OCN_BLUE, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row <  top_bound; row ++)
    {
        r=SinkDataIndexNextRow(r);

        Gxy_result = &iTS->Gxy_InfoPlane[r];
        Axy_result = &iTS->Axy_InfoPlane[r];

        if(row % cell_height == 0)
        {
            for(col = left_bound; col < right_bound; col ++)
            {
                if(col % cell_width == 0)
                {
                    cell_direction_data[cell_direction_data_counter] = (float)O_CalculateCellHogDirection(&Gxy_result[col], &Axy_result[col], cell_width, cell_height, iTS);

                    norm += (cell_direction_data[cell_direction_data_counter] * cell_direction_data[cell_direction_data_counter]);

                    if(cell_direction_data_counter < (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT))
                        cell_direction_data_counter ++;


//                    OSD_Color_Setup(OCN_BLUE, iTS);
//                    DrawRectangle(row, row + cell_height, col, col + cell_width, iTS);
                }
            }
        }
    }


    norm = sqrt(norm + 0.000000001);

    for(index= 0; index <  (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT); index ++)
    {
        if(cell_direction_data[index] == 0)
            cell_direction_data[index] = 0;
        else
            cell_direction_data[index] = cell_direction_data[index]/norm;
    }


    direction_prediction = classifier(adult_direction_weights, cell_direction_data, (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT));
    prediction = classifier(adult_weights, cell_direction_data, (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT));

    if(prediction > ADULT_SEARCH_PREDICTED_TH)
    {
        if(direction_prediction > ADULT_DIRECTION_TH)
             iTS->adult.direction = 1;
        else
             iTS->adult.direction = 0;
//        printf("Prediciton = %lf , Direction Prediciton = %lf\n", prediction, direction_prediction);
//        O_WriteTrainDataToTxt(cell_direction_data, (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT), iTS);
        free(cell_direction_data);
        return 1;
    }

    free(cell_direction_data);
    return 0;

}


//int O_AdultHumanDecision(int star_row, int star_col,int image_width, int image_height, ITS *iTS)
//{
//    int row, col;
//    int index = 0;

//    unsigned char *Gxy_result;
//    unsigned char *Axy_result;

//    int cell_width  = (int)(((double)image_width  / (double)ADULT_DETECT_WIDTH) + 0.5);
//    int cell_height = (int)(((double)image_height / (double)ADULT_DETECT_HIGHT) + 0.5);
//    int width  = cell_width  * ADULT_DETECT_WIDTH;
//    int height = cell_height * ADULT_DETECT_HIGHT;

//    unsigned short top_bound    = 0 ;
//    unsigned short bottom_bound = star_row ;
//    unsigned short left_bound   = star_col;
//    unsigned short right_bound  = 0;


//    int *cell_direction_data;
//    int cell_direction_data_counter = 0;

//    int sum   = 0;
//    int error = 0;


//    double predicted_value = 0;


//    top_bound = bottom_bound + height;
//    right_bound = left_bound + width;

//    if(top_bound > (S_IMGH - height - 5))
//        top_bound = (S_IMGH - height - 5);
//    if(right_bound > S_IMGRB - width -5)
//        right_bound = S_IMGRB - width -5;



//    cell_direction_data = (int *) calloc( (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT), sizeof(int));


////    OSD_Color_Setup(OCN_BLUE, iTS);
////    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//    int r = SinkDataIndexStart(bottom_bound);

//    for(row= bottom_bound; row <  top_bound; row ++)
//    {
//        r=SinkDataIndexNextRow(r);

//        Gxy_result = &iTS->Gxy_InfoPlane[r];
//        Axy_result = &iTS->Axy_InfoPlane[r];

//        if(row % cell_height == 0)
//        {
//            for(col = left_bound; col < right_bound; col ++)
//            {
//                if(col % cell_width == 0)
//                {
//                    cell_direction_data[cell_direction_data_counter] = O_CalculateCellHogDirection(&Gxy_result[col], &Axy_result[col], cell_width, cell_height, iTS);

//                    if(cell_direction_data_counter < (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT))
//                        cell_direction_data_counter ++;


////                    OSD_Color_Setup(OCN_BLUE, iTS);
////                    DrawRectangle(row, row + cell_height, col, col + cell_width, iTS);
//                }
//            }
//        }
//    }




//    for(index= 0; index <  (ADULT_DETECT_WIDTH * ADULT_DETECT_HIGHT); index ++)
//    {
//        if(big_doll_front_data[index] != 0)
//        {


//            error += big_doll_front_data[index ]  - cell_direction_data[index];
//            printf("%d,", cell_direction_data[index]);
//        }
//        else
//        {
//             printf(" ,");
//        }

//        sum += big_doll_front_data[index];

//        if(index % ADULT_DETECT_WIDTH == 0)
//            printf("\n");
//    }
//    printf("\n");


//    predicted_value = 1.0 - ((float)abs(error) / (float)sum);


////    printf("error: %d  sum: %d  predicted_value: %.2f\n", error, sum, predicted_value);

//    if(predicted_value > ADULT_SEARCH_PREDICTED_TH)
//    {

//        free(cell_direction_data);
//        return 1;
//    }

//    free(cell_direction_data);
//    return 0;

//}


int O_FindAdultPeopleCandidate(int star_row, int star_col,int image_width, int image_height, unsigned short *new_bound, ITS *iTS)
{
    int row, col;
    int index = 0;
    unsigned char *CrRow;

    int half_width = image_width>>1;

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = star_row - 3;
    unsigned short left_bound   = star_col - (image_width / 3);
    unsigned short right_bound  = 0;

    int center = star_col + half_width;


    unsigned int hog_projection[37] = {0};
    float data[36] = {0};

    float norm = 0;
    float prediction = 0;


    top_bound = bottom_bound + image_height;
    right_bound = left_bound + image_width;

    if(top_bound > (S_IMGH - 20))
        return 0;
    if(right_bound > S_IMGRB)
        return 0;


//    OSD_Color_Setup(OCN_BLUE, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);


    int r = SinkDataIndexStart(bottom_bound);
    int flag = 0;
    for(row= bottom_bound; row <  top_bound; row++)
    {
        r=SinkDataIndexNextRow(r);

        CrRow = &iTS->Hog_InfoPlane[r];

        for(col = left_bound; col < right_bound; col++)
        {
            if(CrRow[col] != 0)
            {
                if(CrRow[col]>36)
                   hog_projection[36]++;
                else
                    hog_projection[CrRow[col]]++;

                flag = 1;
            }
        }
    }
    if(flag == 0)
        return 0;
    for(index = 1; index <= 36; index++)
    {
        norm += (hog_projection[index] * hog_projection[index]);
    }
    norm = sqrt(norm + 0.000000001);

    for(index = 1; index <= 36; index++)
    {
        if(hog_projection[index] == 0)
            data[index - 1] = 0;
        else
            data[index - 1] = ((float)hog_projection[index] / norm);

    }
    prediction = classifier(adult_candidate_weights, data, 36);


    if(prediction > ADULT_SEARCH_Candidate_TH)
    {
//        OSD_Color_Setup(OCN_BLUE, iTS);
//        DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//        printf("Candidate prediction = %g\n", prediction);

//        O_WriteTrainDataToTxt(data, 36, iTS);


        center = O_FindCorrectBoundary(bottom_bound, left_bound, image_width, (image_height>>1), iTS);


        if(O_AdultHumanDecision(bottom_bound, (center - half_width), image_width,  image_height, iTS))
        {
            new_bound[0] = bottom_bound;
            new_bound[1] = top_bound;
            new_bound[2] = (center - half_width);
            new_bound[3] = (center + half_width);

//                OSD_Color_Setup(OCN_RED, iTS);
//                DrawRectangle(new_bound[0], new_bound[1], new_bound[2], new_bound[3], iTS);


            return 1;
        }
    }
    return 0;
}

//int O_FindAdultPeopleCandidate(int star_row, int star_col,int image_width, int image_height, unsigned short *new_bound, ITS *iTS)
//{
//    int row, col;
//    int index = 0;
//    unsigned char *CrRow;

//    int half_width = image_width>>1;

//    unsigned short top_bound    = 0 ;
//    unsigned short bottom_bound = star_row - 3;
//    unsigned short left_bound   = star_col - (image_width / 3);
//    unsigned short right_bound  = 0;

//    int center = star_col + half_width;


//    unsigned int hog_projection[37];

//    double data_average  = 0;
//    double data_average2 = 0;

//    double Sxy = 0;
//    double Sx = 0;
//    double Sy = 0;
//    double SxSy = 0;
//    double result = 0;

//    float max_value = 0;


//    top_bound = bottom_bound + image_height;
//    right_bound = left_bound + image_width;

//    if(top_bound > (S_IMGH - 5))
//        top_bound = (S_IMGH - 5);
//    if(right_bound > S_IMGRB)
//        right_bound = S_IMGRB;


////    OSD_Color_Setup(OCN_BLUE, iTS);
////    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//    memset(hog_projection, 0, sizeof(hog_projection));

//    int r = SinkDataIndexStart(bottom_bound);

//    for(row= bottom_bound; row <  top_bound; row++)
//    {
//        r=SinkDataIndexNextRow(r);

//        CrRow = &iTS->Hog_InfoPlane[r];

//        for(col = left_bound; col < right_bound; col++)
//        {
//            if(CrRow[col] != 0)
//            {
//                hog_projection[CrRow[col]]++;
//            }
//        }
//    }

//    for(index = 1; index <= 36; index++)
//    {
//        if(hog_projection[index] > max_value)
//            max_value = hog_projection[index];
//    }
//    float proportion = (100.0 / max_value);

//    for(index = 1; index <= 36; index++)
//    {

//        hog_projection[index] = (int)((float)hog_projection[index] * proportion);

//        data_average  += adult_candidate_data[index - 1];
//        data_average2 += hog_projection[index];

////        OSD_Color_Setup(OCN_BLUE, iTS);
////        DrawRectangle(bottom_bound, bottom_bound + hog_projection[index], right_bound + index +3, right_bound + index + 4, iTS);
//    }

//    data_average  = data_average  / 36;
//    data_average2 = data_average2 / 36;

//    for(index = 1; index <= 36; index++)
//    {
//       Sx  += ((adult_candidate_data[index - 1] - data_average) * (adult_candidate_data[index - 1] - data_average));
//       Sy  += ((hog_projection[index] - data_average2) * (hog_projection[index] - data_average2));
//       Sxy += ((adult_candidate_data[index - 1] - data_average) * (hog_projection[index] - data_average2));
//    }
//    SxSy = Sx * Sy;
//    SxSy = sqrt(SxSy);

//    result = Sxy / SxSy;  // r = Sxy / SxSy

////    printf("Candidate Result = %g\n", result);


//    if(result > ADULT_SEARCH_Candidate_TH)
//    {
////        OSD_Color_Setup(OCN_BLUE, iTS);
////        DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);


//        center = O_FindCorrectBoundary(bottom_bound, left_bound, image_width, (image_height>>1), iTS);
////        center = O_FindCorrectBoundary(bottom_bound + (image_height>>1), left_bound, image_width, (image_height>>2), iTS);
////        center = O_FindCorrectBoundary(bottom_bound + (image_height/3), left_bound, image_width, (image_height/3), iTS);

////        center = O_FindCorrectBoundary(bottom_bound + (image_height>>1), left_bound , image_width, (image_height>>2), iTS);

//      //  if(O_AdultHumanDecision(bottom_bound, (center - half_width), image_width,  image_height, iTS))
//        {
//            new_bound[0] = bottom_bound;
//            new_bound[1] = top_bound;
//            new_bound[2] = (center - half_width);
//            new_bound[3] = (center + half_width);

////                OSD_Color_Setup(OCN_RED, iTS);
////                DrawRectangle(new_bound[0], new_bound[1], new_bound[2], new_bound[3], iTS);


//            return 1;
//        }
//    }
//    return 0;

//}




int O_SearchChildPedestrian(ITS *iTS)
{
#define FROM_EDGE
//#define FROM_HOG

    int row, col;

    unsigned short top_bound = L_IB_TB_TrackingLane;//S_IMGCH ;
    unsigned short bottom_bound = L_IB_BB_SearchLane;
    unsigned short left_bound   = S_IMGCW;// S_IMGLB;
    unsigned short right_bound  = S_IMGRB;

    unsigned short new_bound[4] = {0};


    unsigned char *CrRow,*UpRow,*Up2Row;

    int width  = 0;
    int height = 0;


    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row<  top_bound; row++)
    {
        r=SinkDataIndexNextRow(r);

#ifdef FROM_HOG
        CrRow  = &iTS->Hog_InfoPlane[r];
        UpRow  = &iTS->Hog_InfoPlane[r-iTS->F_W];
        Up2Row = &iTS->Hog_InfoPlane[r-iTS->F_W-iTS->F_W];
#endif
#ifdef FROM_EDGE
        CrRow  = &iTS->O_InfoPlane[r];
        UpRow  = &iTS->O_InfoPlane[r-iTS->F_W];
        Up2Row = &iTS->O_InfoPlane[r-iTS->F_W-iTS->F_W];
#endif


        width  = DWtoDI(CHILD_DETECT_WIDTH, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));
        height = DWtoDI(CHILD_DETECT_HIGHT, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));

        if(width < 10)
           width = 10;
        if(height < 15)
           height = 15;


//        OSD_Color_Setup(OCN_YELLOW, iTS);
//        DrawColorLine(row, iTS->L_LaneMBound[row].Scd + 10, right_bound, iTS);

        for(col = iTS->L_LaneMBound[row].Scd + 10; col < right_bound + width; col++)
//        for(col = left_bound; col < right_bound + width; col++)
        {

#ifdef FROM_HOG
            if(CrRow[col] != 0 && UpRow[col] != 0 && Up2Row[col] != 0)
#endif
#ifdef FROM_EDGE
            if((CrRow[col] & VEINFO) == VEINFO && (UpRow[col] & VEINFO) == VEINFO && (Up2Row[col] & VEINFO) == VEINFO)
#endif
            {
                if(O_FindChildPeopleCandidate(row, col, width, height, &new_bound[0], iTS))
                {
                    iTS->child.boundary.BB = new_bound[0];
                    iTS->child.boundary.TB = new_bound[1];
                    iTS->child.boundary.LB = new_bound[2];
                    iTS->child.boundary.RB = new_bound[3];
                    iTS->child.boundary.BH = height;
                    iTS->child.boundary.BW = width;

//                    OSD_Color_Setup(OCN_GREEN, iTS);
//                    DrawRectangle(iTS->child.boundary.BB, iTS->child.boundary.TB, iTS->child.boundary.LB, iTS->child.boundary.RB, iTS);


                    return 1;
                }
            }
        }
    }

    iTS->child.stable_counter = 0;
    iTS->child.mode = SEARCH;
    iTS->child.distance = 0;
    iTS->child.boundary.BB = 0;
    iTS->child.boundary.TB = 0;
    iTS->child.boundary.LB = 0;
    iTS->child.boundary.RB = 0;
    iTS->child.boundary.BH = 0;
    iTS->child.boundary.BW = 0;

    return 0;
}

int O_TrackingChildPedestrian(ITS *iTS)
{
#define FROM_EDGE
//#define FROM_HOG

    int row, col;

    unsigned short top_bound    = iTS->child.boundary.TB;
    unsigned short bottom_bound = iTS->child.boundary.BB - (iTS->child.boundary.BH >> 1);
    unsigned short left_bound   = iTS->child.boundary.LB - (iTS->child.boundary.BW /2);
    unsigned short right_bound  = iTS->child.boundary.RB + (iTS->child.boundary.BW /1);


    if(top_bound > (S_IMGH - 5))
        top_bound = (S_IMGH - 5);
    if(bottom_bound < (L_IB_BB_SearchLane + 1))
        bottom_bound = (L_IB_BB_SearchLane + 1);
    if(right_bound > S_IMGRB)
        right_bound = S_IMGRB;
    if(left_bound < S_IMGCW - 200)
        left_bound = S_IMGCW - 200;

    unsigned short new_bound[4] = {0};

     unsigned char *CrRow,*UpRow,*Up2Row;

     int width  = 0;
     int height = 0;


     int r = SinkDataIndexStart(bottom_bound);

     for(row= bottom_bound; row<  top_bound; row++)
     {
         r=SinkDataIndexNextRow(r);

 #ifdef FROM_HOG
         CrRow  = &iTS->Hog_InfoPlane[r];
         UpRow  = &iTS->Hog_InfoPlane[r-iTS->F_W];
         Up2Row = &iTS->Hog_InfoPlane[r-iTS->F_W-iTS->F_W];
 #endif
 #ifdef FROM_EDGE
         CrRow  = &iTS->O_InfoPlane[r];
         UpRow  = &iTS->O_InfoPlane[r-iTS->F_W];
         Up2Row = &iTS->O_InfoPlane[r-iTS->F_W-iTS->F_W];
 #endif

         width  = DWtoDI(CHILD_DETECT_WIDTH, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));
         height = DWtoDI(CHILD_DETECT_HIGHT, (EV_ROAD_SLOPE - (row  - iTS->F_H_C)));

         if(width < 10)
            width = 10;
         if(height < 15)
            height = 15;

         for(col = left_bound; col < right_bound - width; col++)
         {

 #ifdef FROM_HOG
             if(CrRow[col] != 0 && UpRow[col] != 0 && Up2Row[col] != 0)
 #endif
 #ifdef FROM_EDGE
             if((CrRow[col] & VEINFO) == VEINFO && (UpRow[col] & VEINFO) == VEINFO && (Up2Row[col] & VEINFO) == VEINFO)
//             if((CrRow[col] & HEINFO) == HEINFO && (CrRow[col+1] & HEINFO) == HEINFO && (CrRow[col+2] & HEINFO) == HEINFO)
 #endif
             {
                 if(O_FindChildPeopleCandidate(row, col, width, height, &new_bound[0], iTS))
                 {
                     if(abs(height - iTS->child.boundary.BH) < (iTS->child.boundary.BH >>2))
                     {
                         iTS->child.boundary.BB += new_bound[0];
                         iTS->child.boundary.BB = iTS->child.boundary.BB >> 1;
                         iTS->child.boundary.TB += new_bound[1];
                         iTS->child.boundary.TB = iTS->child.boundary.TB >>1;
                         iTS->child.boundary.LB += new_bound[2];
                         iTS->child.boundary.LB = iTS->child.boundary.LB >>1;
                         iTS->child.boundary.RB += new_bound[3];
                         iTS->child.boundary.RB = iTS->child.boundary.RB >>1;
                         iTS->child.boundary.BH += height;
                         iTS->child.boundary.BH = iTS->child.boundary.BH >> 1;
                         iTS->child.boundary.BW += width;
                         iTS->child.boundary.BW = iTS->child.boundary.BW >> 1;



//                         OSD_Color_Setup(OCN_BLUE, iTS);
//                         DrawRectangle(iTS->child.boundary.BB, iTS->child.boundary.TB, iTS->child.boundary.LB, iTS->child.boundary.RB, iTS);
                         return 1;
                     }

                 }
             }
         }
     }


    return 0;
}


int O_FindChildPeopleCandidate(int star_row, int star_col,int image_width, int image_height, unsigned short *new_bound, ITS *iTS)
{
    int row, col;
    int index = 0;
    unsigned char *CrRow;

    int half_width = image_width>>1;

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = star_row - 5;
    unsigned short left_bound   = star_col - (image_width / 4);
    unsigned short right_bound  = 0;

    int center = star_col + half_width;


    unsigned int hog_projection[38] = {0};
    float data[36] = {0};

    float norm = 0;
    float prediction = 0;


    top_bound = bottom_bound + image_height;
    right_bound = left_bound + image_width;

    if(top_bound > (S_IMGH - 50))
        return 0;
    if(right_bound > S_IMGRB)
        return 0;


    if(O_GetDistance(star_row, iTS) > 120)
        return 0;


//    OSD_Color_Setup(OCN_BLUE, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//    memset(hog_projection, 0, sizeof(hog_projection));

    for(row= 0; row <  37; row++)
    {
        hog_projection[row] = 0;
    }

    int flag = 0;
    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row <  top_bound; row++)
    {
        r=SinkDataIndexNextRow(r);

        CrRow = &iTS->Hog_InfoPlane[r];

        for(col = left_bound; col < right_bound; col++)
        {
            if(CrRow[col] != 0)
            {
                if(CrRow[col] > 36)
                    hog_projection[36]++;
                else
                    hog_projection[CrRow[col]]++;
                flag = 1;
            }
        }
    }

    if(flag == 0)
        return 0;

    for(index = 1; index <= 36; index++)
    {
        norm += (double)(hog_projection[index] * hog_projection[index]);
    }

    norm = sqrt(norm + 0.000000001);

    for(index = 1; index <= 36; index++)
    {
        if(hog_projection[index] == 0)
            data[index - 1] = 0;
        else
            data[index - 1] = ((float)hog_projection[index] / norm);

    }

    prediction = classifier(child_candidate_weights, data, 36);


    if(prediction > CHILD_SEARCH_Candidate_TH)
    {
//        printf("Candidate prediction = %g\n", prediction);
//        O_WriteTrainDataToTxt(data, 36, iTS);


        center = O_FindCorrectBoundary(bottom_bound, left_bound, image_width, (image_height>>1), iTS);
//        center = star_col + half_width;
        if(O_ChildHumanDecision(bottom_bound, (center - half_width), image_width,  image_height, iTS))
        //if(O_ChildHumanDecision(bottom_bound, left_bound, image_width,  image_height, iTS))
        {
//            OSD_Color_Setup(OCN_BLUE, iTS);
//            DrawRectangle(bottom_bound, bottom_bound + image_height, left_bound, right_bound, iTS);

            new_bound[0] = bottom_bound;
            new_bound[1] = top_bound;
            new_bound[2] = (center - half_width);
            new_bound[3] = (center + half_width);

//            new_bound[2] = left_bound;
//            new_bound[3] = right_bound;


            return 1;
        }
    }

    return 0;

}

//int O_FindChildPeopleCandidate(int star_row, int star_col,int image_width, int image_height, unsigned short *new_bound, ITS *iTS)
//{
//    int row, col;
//    int index = 0;
//    unsigned char *CrRow;

//    int half_width = image_width>>1;

//    unsigned short top_bound    = 0 ;
//    unsigned short bottom_bound = star_row - 5;
//    unsigned short left_bound   = star_col - (image_width / 4);
//    unsigned short right_bound  = 0;

//    int center = star_col + half_width;


//    unsigned int hog_projection[37];

//    double data_average  = 0;
//    double data_average2 = 0;

//    double Sxy = 0;
//    double Sx = 0;
//    double Sy = 0;
//    double SxSy = 0;
//    double result = 0;

//    float max_value = 0;


//    top_bound = bottom_bound + image_height;
//    right_bound = left_bound + image_width;

//    if(top_bound > (S_IMGH - 5))
//        top_bound = (S_IMGH - 5);
//    if(right_bound > S_IMGRB)
//        right_bound = S_IMGRB;


//    if(O_GetDistance(star_row, iTS) > 120)
//        return 0;


////    OSD_Color_Setup(OCN_BLUE, iTS);
////    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//    memset(hog_projection, 0, sizeof(hog_projection));

//    int r = SinkDataIndexStart(bottom_bound);

//    for(row= bottom_bound; row <  top_bound; row++)
//    {
//        r=SinkDataIndexNextRow(r);

//        CrRow = &iTS->Hog_InfoPlane[r];

//        for(col = left_bound; col < right_bound; col++)
//        {
//            if(CrRow[col] != 0)
//            {
//                hog_projection[CrRow[col]]++;
//            }
//        }
//    }

//    for(index = 1; index <= 36; index++)
//    {
//        if(hog_projection[index] > max_value)
//            max_value = hog_projection[index];
//    }
//    float proportion = (100.0 / max_value);

//    for(index = 1; index <= 36; index++)
//    {

//        hog_projection[index] = (int)((float)hog_projection[index] * proportion);

//        data_average  += child_candidate_data[index - 1];
//        data_average2 += hog_projection[index];

////        OSD_Color_Setup(OCN_BLUE, iTS);
////        DrawRectangle(bottom_bound, bottom_bound + hog_projection[index], right_bound + index +3, right_bound + index + 4, iTS);
//    }

//    data_average  = data_average  / 36;
//    data_average2 = data_average2 / 36;

//    for(index = 1; index <= 36; index++)
//    {
//       Sx  += ((child_candidate_data[index - 1] - data_average) * (child_candidate_data[index - 1] - data_average));
//       Sy  += ((hog_projection[index] - data_average2) * (hog_projection[index] - data_average2));
//       Sxy += ((child_candidate_data[index - 1] - data_average) * (hog_projection[index] - data_average2));
//    }
//    SxSy = Sx * Sy;
//    SxSy = sqrt(SxSy);

//    result = Sxy / SxSy;  // r = Sxy / SxSy
////    printf("Child Candidate Result = %g\n", result);


//    if(result > CHILD_SEARCH_Candidate_TH)
//    {
//        center = O_FindCorrectBoundary(bottom_bound, left_bound, image_width, (image_height>>1), iTS);


//        if(O_ChildHumanDecision(bottom_bound, (center - half_width), image_width,  image_height, iTS))
//        {
//            new_bound[0] = bottom_bound;
//            new_bound[1] = top_bound;
//            new_bound[2] = (center - half_width);
//            new_bound[3] = (center + half_width);


//            return 1;
//        }
//    }

//    return 0;

//}


int O_ChildHumanDecision(int star_row, int star_col,int image_width, int image_height, ITS *iTS)
{
    int row, col;
    int index = 0;

    unsigned char *Gxy_result;
    unsigned char *Axy_result;

    int cell_width  = (int)(((float)image_width  / (float)CHILD_DETECT_WIDTH) + 0.5);
    int cell_height = (int)(((float)image_height / (float)CHILD_DETECT_HIGHT) + 0.5);

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = star_row ;
    unsigned short left_bound   = star_col;
    unsigned short right_bound  = 0;


    int width  = cell_width * CHILD_DETECT_WIDTH;
    int height = cell_height * CHILD_DETECT_HIGHT;


    float *cell_direction_data;
    int cell_direction_data_counter = 0;


    double norm = 0;

    float prediction = 0;


    top_bound = bottom_bound + height;
    right_bound = left_bound + width;

    if(top_bound > (S_IMGH - 20))
        return 0;
    if(right_bound > S_IMGRB)
        return 0;


    cell_direction_data = (float *) calloc( (CHILD_DETECT_WIDTH * CHILD_DETECT_HIGHT), sizeof(float));

//    OSD_Color_Setup(OCN_BLUE, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row <  top_bound; row ++)
    {
        r=SinkDataIndexNextRow(r);

        Gxy_result = &iTS->Gxy_InfoPlane[r];
        Axy_result = &iTS->Axy_InfoPlane[r];

        if(row % cell_height == 0)
        {
            for(col = left_bound; col < right_bound; col ++)
            {
                if(col % cell_width == 0)
                {

                    cell_direction_data[cell_direction_data_counter] = (float)O_CalculateHogCellDirection(&Gxy_result[col], &Axy_result[col], cell_width, cell_height, iTS);
                    norm += (cell_direction_data[cell_direction_data_counter] * cell_direction_data[cell_direction_data_counter]);

                    if(cell_direction_data_counter < ((CHILD_DETECT_WIDTH) * (CHILD_DETECT_HIGHT)))
                        cell_direction_data_counter ++;

//                    OSD_Color_Setup(OCN_BLUE, iTS);
//                    DrawRectangle(row, row + cell_height, col, col + cell_width, iTS);
                }
            }
        }
    }


    norm = sqrt(norm + 0.000000001);
    for(index = 0; index < (CHILD_DETECT_WIDTH) * (CHILD_DETECT_HIGHT); index++)
    {
        if(cell_direction_data[index] == 0)
            cell_direction_data[index] = 0;
        else
            cell_direction_data[index] = (cell_direction_data[index] / norm);
    }

    prediction = classifier(child_weights, cell_direction_data, (CHILD_DETECT_HIGHT) * (CHILD_DETECT_WIDTH));

    if(iTS->child.mode == TRACE /*&& prediction > CHILD_SEARCH_PREDICTED_TH*/)
    {

       // printf("Prediciton = %lf\n", prediction);
//        O_WriteTrainDataToTxt(cell_direction_data, (CHILD_DETECT_HIGHT) * (CHILD_DETECT_WIDTH), iTS);

//        index = 0;
//        printf("------------------------\n");
//        printf("{");
//        for(row= 0; row<  CHILD_DETECT_HIGHT ; row ++)
//        {
//            for(col = 0; col < CHILD_DETECT_WIDTH; col ++)
//            {
//                if(index == (((CHILD_DETECT_HIGHT) * (CHILD_DETECT_WIDTH)) - 1 ))
//                    printf("%.3f}\n", cell_direction_data[index]);
//                else
//                    printf("%.3f; ", cell_direction_data[index]);

//                index++;
//            }
//            printf("\n ");
//        }
//        printf("------------------------\n");

    }

   if(prediction > CHILD_SEARCH_PREDICTED_TH)
    {
//        printf("Prediciton = %lf\n", prediction);
        free(cell_direction_data);
        return 1;
    }


    free(cell_direction_data);
    return 0;

}


int O_FindCorrectBoundary(int star_row, int star_col,int image_width, int image_height,  ITS *iTS)
{
    int row, col;
    unsigned char *CrRow;

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = star_row;
    unsigned short left_bound   = star_col;
    unsigned short right_bound  = 0;

    int half_width = image_width>>1;


    unsigned int projection_v_edge[image_width];

    unsigned int max_value = 0;
    int left_boundary  = 0;
    int right_boundary = 0;
    int center         = half_width;

    top_bound = bottom_bound + image_height;
    right_bound = left_bound + image_width;

    if(top_bound > (S_IMGH - 5))
        top_bound = (S_IMGH - 5);
    if(right_bound > S_IMGRB)
        right_bound = S_IMGRB;


//    OSD_Color_Setup(OCN_BLUE, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//    projection_v_edge = (unsigned int *) calloc(image_width, sizeof(unsigned int));
    memset(projection_v_edge, 0, sizeof(projection_v_edge));

    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row<  top_bound; row++)
    {
        r=SinkDataIndexNextRow(r);

        CrRow = &iTS->O_InfoPlane[r];

        for(col = 0; col < image_width; col++)
        {
            if((CrRow[col + left_bound] & VEINFO) == VEINFO)
            {
                projection_v_edge[col]++;
            }
        }
    }

    for(col = 0; col < half_width; col++)
    {
        if(projection_v_edge[col] > max_value)
        {
            max_value = projection_v_edge[col];
            left_boundary = col;
        }
    }
    max_value = 0;
    for(col = image_width - 1; col > half_width; col--)
    {
        if(projection_v_edge[col] > max_value)
        {
            max_value = projection_v_edge[col];
            right_boundary = col;
        }
    }
    center = (((right_boundary - left_boundary) >> 1) + left_boundary) + star_col;

//    OSD_Color_Setup(OCN_RED, iTS);
//    DrawRectangle(bottom_bound, top_bound, center, center + 1, iTS);

    return center;

}


int O_CalculateCellHogDirection(unsigned char *Gxy_result, unsigned char *Axy_result, int cell_width, int cell_height, ITS *iTS)
{
    int row, col;
    int index = 0;
    int col_ = 0;
    unsigned int max_value = 0;
    int max_direction = 0;

    unsigned int hog_projection[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};


    for(row= 0; row <  cell_height; row ++)
    {
        for(col = 0; col < cell_width; col ++)
        {
            col_ = col - (iTS->F_W * row);
            hog_projection[Axy_result[col_] - 1] += Gxy_result[col_];

        }
    }

    for(index = 0; index <  9; index ++)
    {
        if(hog_projection[index] > max_value)
        {
            max_value = hog_projection[index];
            max_direction = index + 1;
        }
    }

    return max_direction;
}

int O_CalculateHogCellDirection(unsigned char *Gxy_result, unsigned char *Axy_result, int cell_width, int cell_height, ITS *iTS)
{
    int row, col;
    int index = 0;
    int col_ = 0;
    int sum_value = 0;

    unsigned int hog_projection[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};


    for(row= 0; row <  cell_height; row ++)
    {
        for(col = 0; col < cell_width; col ++)
        {
            col_ = col - (iTS->F_W * row);
            hog_projection[Axy_result[col_] - 1] += Gxy_result[col_];

        }
    }

    for(index = 0; index <  9; index ++)
    {
        if(hog_projection[index] != 0)
        {
            sum_value += hog_projection[index] * (index + 1);
        }
    }

    return sum_value;
}

float classifier(float *weight, float *data, int data_amount)
{
    // CALCULATE PREDICTION
    int index = 0;
    float prediction = 0;
    float error = weight[0];
    for(index = 1; index <= data_amount; index++)
    {
        error += (weight[index] * data[index-1]);
    }
    prediction = 1.0/(1.0 + exp(-error));
//    printf("Prediciton = %lf\n", prediction);

    return prediction;
}

void O_Training_LR_Datan(int XOffset, int YOffset, int width, int height, ITS *iTS)
{
    int row, col;
    int index = 0;
    unsigned char *Gxy_result;
    unsigned char *Axy_result;

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = YOffset;
    unsigned short left_bound   = XOffset;
    unsigned short right_bound  = 0;

    int image_width  = 0;
    int image_height = 0;
    int cell_width  = 0;
    int cell_height = 0;

    float *cell_direction_data;
    int cell_direction_data_counter = 0;

    double norm = 0;

//    cell_width  = DWtoDI(1, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
//    cell_height = DWtoDI(1, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));
//    image_width  = cell_width * width;
//    image_height = cell_height * height;

    image_width  = DWtoDI(width, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
    image_height = DWtoDI(height, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));

    cell_width  = (int)(((double)image_width  / (double)width) + 0.5);
    cell_height = (int)(((double)image_height / (double)height) + 0.5);

//    cell_width  = image_width  / width;
//    cell_height = image_height / height;

    image_width = cell_width * width;
    image_height = cell_height * height;

    top_bound = bottom_bound + image_height;
    right_bound = left_bound + image_width;


    cell_direction_data = (float *) calloc( (width * height), sizeof(float));


    OSD_Color_Setup(OCN_YELLOW, iTS);
    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);



    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row <  top_bound; row ++)
    {
        r=SinkDataIndexNextRow(r);

        Gxy_result = &iTS->Gxy_InfoPlane[r];
        Axy_result = &iTS->Axy_InfoPlane[r];

        if(row % cell_height == 0)
        {
            for(col = left_bound; col < right_bound; col ++)
            {
                if(col % cell_width == 0)
                {
                    cell_direction_data[cell_direction_data_counter] = (float)O_CalculateHogCellDirection(&Gxy_result[col], &Axy_result[col], cell_width, cell_height, iTS);
                    norm += (cell_direction_data[cell_direction_data_counter] * cell_direction_data[cell_direction_data_counter]);


                    if(cell_direction_data_counter < (width * height))
                        cell_direction_data_counter ++;

                    OSD_Color_Setup(OCN_BLUE, iTS);
                    DrawRectangle(row, row + cell_height, col, col + cell_width, iTS);
                }
            }
        }
    }

    norm = sqrt(norm + 0.000000001);
    for(index = 0; index < (width * height); index++)
    {
        cell_direction_data[index] = (cell_direction_data[index] / norm);
    }


    if(iTS->training_counter >= 100)
    {
        O_WriteTrainDataToTxt(cell_direction_data, height * width , iTS);
        index = 0;
        printf("------------------------\n");
        printf("{");
        for(row= 0; row<  height ; row ++)
        {
            for(col = 0; col < width; col ++)
            {
                if(index == (((height) * (width)) - 1 ))
                    printf("%.5f}\n", cell_direction_data[index]);
                else
                    printf("%.5f; ", cell_direction_data[index]);

                index++;
            }
            printf("\n ");
        }
        printf("------------------------\n");
    }
    iTS->training_counter++;

    free(cell_direction_data);

}

void O_CandidateTrainingData(int XOffset, int YOffset, int width, int height, ITS *iTS)
{
    int row, col;
    int index = 0;
    unsigned char *CrRow;

    unsigned short top_bound    = 0 ;
    unsigned short bottom_bound = YOffset;
    unsigned short left_bound   = XOffset;
    unsigned short right_bound  = 0;

    int image_width  = 0;
    int image_height = 0;

    unsigned int hog_projection[37] = {0};
    float data [36] = {0};


    float norm = 0;

    image_width  = DWtoDI(width, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
    image_height = DWtoDI(height, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));



    top_bound = bottom_bound + image_height;
    right_bound = left_bound + image_width;


    OSD_Color_Setup(OCN_YELLOW, iTS);
    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

    memset(hog_projection, 0, sizeof(hog_projection));


    int r = SinkDataIndexStart(bottom_bound);

    for(row= bottom_bound; row<  top_bound; row++)
    {
        r=SinkDataIndexNextRow(r);

        CrRow = &iTS->Hog_InfoPlane[r];

        for(col = left_bound; col < right_bound; col++)
        {
            if(CrRow[col] != 0)
            {
                hog_projection[CrRow[col]]++;
            }
        }
    }

    for(index = 1; index <= 36; index++)
    {
        norm += (hog_projection[index] * hog_projection[index]);
    }
    norm = sqrt(norm + 0.000000001);

    for(index = 1; index <= 36; index++)
    {
        if(hog_projection[index] == 0)
            data[index - 1] = 0;
        else
            data[index - 1] = (float)hog_projection[index] / norm;
    }

   if(iTS->training_counter >= 100)
   {
       O_WriteTrainDataToTxt(data, 36, iTS);
       iTS->training_counter = 0;
   }


    iTS->training_counter++;
}

void O_WriteTrainDataToTxt(float *data, int number, ITS *iTS)
{
    int index = 0;
    for(index= 0; index <  number ; index ++)
    {

        if(index == (number - 1 ))
        {
            fprintf(iTS->traindata,"%.5f \r\n" ,data[index]);
            printf("%.5f \r\n" ,data[index]);
        }
        else
        {
            fprintf(iTS->traindata,"%.5f " ,data[index]);
            printf("%.5f " ,data[index]);
        }
    }
}


//void O_Training(int XOffset, int YOffset, int width, int height, ITS *iTS)
//{
//    int row, col;
//    int index = 0;
//    unsigned char *Gxy_result;
//    unsigned char *Axy_result;

//    unsigned short top_bound    = 0 ;
//    unsigned short bottom_bound = YOffset;
//    unsigned short left_bound   = XOffset;
//    unsigned short right_bound  = 0;

//    int image_width  = 0;
//    int image_height = 0;
//    int cell_width  = 0;
//    int cell_height = 0;

//    int max_value = 0;

//    int *cell_direction_data;
//    int cell_direction_data_counter = 0;

////    cell_width  = DWtoDI(1, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
////    cell_height = DWtoDI(1, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));
////    image_width  = cell_width * width;
////    image_height = cell_height * height;

//    image_width  = DWtoDI(width, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
//    image_height = DWtoDI(height, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));

//    cell_width  = (int)(((double)image_width  / (double)width) + 0.5);
//    cell_height = (int)(((double)image_height / (double)height) + 0.5);

////    cell_width  = image_width  / width;
////    cell_height = image_height / height;

//    image_width = cell_width * width;
//    image_height = cell_height * height;

//    top_bound = bottom_bound + image_height;
//    right_bound = left_bound + image_width;


//    cell_direction_data = (int *) calloc( width * height, sizeof(int));


//    OSD_Color_Setup(OCN_YELLOW, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);



//    int r = SinkDataIndexStart(bottom_bound);

//    for(row= bottom_bound; row <  top_bound; row ++)
//    {
//        r=SinkDataIndexNextRow(r);

//        Gxy_result = &iTS->Gxy_InfoPlane[r];
//        Axy_result = &iTS->Axy_InfoPlane[r];

//        if(row % cell_height == 0)
//        {
//            for(col = left_bound; col < right_bound; col ++)
//            {
//                if(col % cell_width == 0)
//                {
////                    cell_direction_data[cell_direction_data_counter] = O_CalculateCellHogDirection(&Gxy_result[col], &Axy_result[col], cell_width, cell_height, iTS);
//                    cell_direction_data[cell_direction_data_counter] = O_CalculateHogCellDirection(&Gxy_result[col], &Axy_result[col], cell_width, cell_height, iTS);


//                    if(cell_direction_data[cell_direction_data_counter] > max_value)
//                        max_value = cell_direction_data[cell_direction_data_counter];

//                    if(cell_direction_data_counter < (width * height))
//                        cell_direction_data_counter ++;

//                    OSD_Color_Setup(OCN_BLUE, iTS);
//                    DrawRectangle(row, row + cell_height, col, col + cell_width, iTS);
//                }
//            }
//        }
//    }

//    float proportion = (100.0 / max_value);
//    for(index = 0; index < (width * height); index++)
//    {
//        cell_direction_data[index] = (int)((float)cell_direction_data[index] * proportion);


//        OSD_Color_Setup(OCN_RED, iTS);
//        DrawRectangle(bottom_bound, bottom_bound + cell_direction_data[index], right_bound + index +3, right_bound + index + 4, iTS);
//    }


//    index = 0;
//    printf("{");
//    for(row= 0; row<  height ; row ++)
//    {
//        for(col = 0; col < width; col ++)
//        {
//            if(index == (((width) * (height)) - 1 ))
//                printf("%3d}\n", cell_direction_data[index]);
//            else
//                printf("%3d,", cell_direction_data[index]);

//            index++;
//        }
//        printf("\n");
//    }
//    printf("------------------------\n");

//    free(cell_direction_data);

//}

//void O_TrainingCandidate(int XOffset, int YOffset, int width, int height, ITS *iTS)
//{
//    int row, col;
//    int index = 0;
//    unsigned char *CrRow;

//    unsigned short top_bound    = 0 ;
//    unsigned short bottom_bound = YOffset;
//    unsigned short left_bound   = XOffset;
//    unsigned short right_bound  = 0;

//    int image_width  = 0;
//    int image_height = 0;
////    int cell_image_width  = 0;
////    int cell_image_height = 0;

//    unsigned int hog_projection[37];

//    float max_value = 0;

////    cell_image_width  = DWtoDI(1, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
////    cell_image_height = DWtoDI(1, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));

////    image_width  = cell_image_width * width;
////    image_height = cell_image_height * height;

//    image_width  = DWtoDI(width, (EV_ROAD_SLOPE - (bottom_bound  - iTS->F_H_C)));
//    image_height = DWtoDI(height, (EV_ROAD_SLOPE - (bottom_bound   - iTS->F_H_C)));



//    top_bound = bottom_bound + image_height;
//    right_bound = left_bound + image_width;


//    OSD_Color_Setup(OCN_YELLOW, iTS);
//    DrawRectangle(bottom_bound, top_bound, left_bound, right_bound, iTS);

//    memset(hog_projection, 0, sizeof(hog_projection));



//    int r = SinkDataIndexStart(bottom_bound);

//    for(row= bottom_bound; row<  top_bound; row++)
//    {
//        r=SinkDataIndexNextRow(r);

//        CrRow = &iTS->Hog_InfoPlane[r];

//        for(col = left_bound; col < right_bound; col++)
//        {
//            if(CrRow[col] != 0)
//            {
//                hog_projection[CrRow[col]]++;
//            }
//        }
//    }

//    for(index = 1; index <= 36; index++)
//    {
//        if(hog_projection[index] > max_value)
//            max_value = hog_projection[index];
//    }
//    float proportion = (100.0 / max_value);


////    printf("max_value %g proportion %g\n", max_value, proportion);
//    for(index = 1; index <= 36; index++)
//    {

//        hog_projection[index] = (int)((float)hog_projection[index] * proportion);
////        printf("%g\n", hog_projection[index]);
//        iTS->projection_data_average[index - 1] += hog_projection[index];

//        OSD_Color_Setup(OCN_BLUE, iTS);
//        DrawRectangle(bottom_bound, bottom_bound + hog_projection[index], right_bound + index +3, right_bound + index + 4, iTS);
//    }
//    iTS->training_counter++;

//    if(iTS->training_counter == 1000)
//    {
//        printf("{");
//        for(index = 0; index < 36; index++)
//        {
//            iTS->training_data[index] = (iTS->projection_data_average[index] / 1000);
//            if(index != 35)
//                printf("%d,", iTS->training_data[index]);
//            else
//                printf("%d}\n", iTS->training_data[index]);
//        }
//        printf("------------------------\n");


//    }
//    else if(iTS->training_counter > 1000)
//    {
//        iTS->training_counter = 0;
//        memset(iTS->projection_data_average, 0,sizeof(iTS->projection_data_average));
//    }
//}







